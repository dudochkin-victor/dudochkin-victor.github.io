<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Синхронизация | Dudochkin Victor </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="google-site-verification" content="Kepqb6k6uptlwngnHbBVJmqQtwNW8zfHyQBbTXLYAgA" />
    <meta name="yandex-verification" content="8e8bc73c2566b473" />
    <style>
    :root {
        /* Primary theme color */
        /* --primary-color: #121A26; */
        --primary-color: #0f1419;
        /* Primary theme text color */
        /* --primary-text-color: #121A26; */
        --primary-text-color: #0f1419;
        /* Primary theme link color */
        --primary-link-color: #053961;
        /* Secondary color: the background body color */
        --secondary-color: #F0F0F0;
        --secondary-text-color: #1C2834;
        /* Highlight text color of table of content */
        --toc-highlight-text-color: #053961;
    }
</style>
    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-47MMPLLY44"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-47MMPLLY44');
    </script>
    

    
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
    
        ym('87064264', "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/87064264" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    
    
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="/mdl.min.css">
    <link rel="stylesheet" href="https://dudochkin-victor.github.io/style.css">
    
    
</head>

<body>
    
<header class="box-shadow">
    

<a href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;">
    <div class="logo">
        <img src="https://dudochkin-victor.github.io/ferris.png" alt="logo">
        Dudochkin Victor
    </div>
</a>

<nav>
    <!-- 
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;showcases&#x2F;">Showcases</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;changelog&#x2F;">Changelog</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;about&#x2F;">About</a>
     -->

    
        
        <a class="nav-item subtitle-text" href="&#x2F;solana&#x2F;">Solana</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;edgeware&#x2F;">Edgeware</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;blog&#x2F;">Блог</a>
        
        <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;github.com&#x2F;dudochkin-victor">Github</a>
        
    
</nav>

</header>

 
    <main>
        
        
        
        
        
        <div class="toc">
            <div class="toc-sticky">
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/cluster/synchronization/#otnoshenie-k-vdf">Отношение к VDF</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/cluster/synchronization/#sviaz-s-mekhanizmami-konsensusa">Связь с механизмами консенсуса</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/cluster/synchronization/#podrobnee-o-proof-of-history">Подробнее о Proof of History</a>
                </div>
                
                
            </div>
        </div>
        
        

        <div class="content text">
            
<h1>Синхронизация</h1>

<p>Быстрая и надежная синхронизация — главная причина, по которой Solana может достичь такой высокой пропускной способности. Традиционные блокчейны синхронизируются на больших фрагментах транзакций, называемых блоками. При синхронизации блоков транзакция не может быть обработана до тех пор, пока не истечет продолжительность, называемая «время блока». В консенсусе Proof of Work это время блока должно быть очень большим (~ 10 минут), чтобы свести к минимуму вероятность того, что несколько валидаторов создадут новый действительный блок одновременно. В консенсусе Proof of Stake такого ограничения нет, но без надежных временных меток валидатор не может определить порядок входящих блоков. Популярным обходным решением является пометка каждого блока <a href="https://en.bitcoin.it/wiki/Block_timestamp">временной меткой настенных часов</a>. Из-за дрейфа часов и различий в сетевых задержках метка времени точна только в пределах часа или двух. Чтобы обойти обходной путь, эти системы удлиняют время блока, чтобы обеспечить разумную уверенность в том, что медианная метка времени в каждом блоке всегда увеличивается.</p>
<p>Солана использует совершенно другой подход, который она называет <em>Proof of History</em> или <em>PoH</em>. Узлы-лидеры «отмечают время» блоков с криптографическими доказательствами того, что с момента последнего доказательства прошло некоторое время. Все данные, хэшированные в доказательство, наверняка произошли до того, как доказательство было сгенерировано. Затем узел делится новым блоком с узлами-валидаторами, которые могут проверить эти доказательства. Блоки могут поступать к валидаторам в любом порядке или даже могут быть воспроизведены спустя годы. С такими надежными гарантиями синхронизации Solana может разбивать блоки на более мелкие пакеты транзакций, называемые <em>записями</em>. Записи передаются валидаторам в режиме реального времени, до того, как будет достигнут консенсус по блокам.</p>
<p>Технически Солана никогда не отправляет <em>блок</em>, но использует этот термин для описания последовательности записей, за которые голосуют валидаторы для достижения <em>подтверждения</em>. Таким образом, время подтверждения Соланы можно сравнить с блочными системами. Текущая реализация устанавливает время блока на 800 мс.</p>
<p>Что происходит под капотом, так это то, что записи передаются валидаторам так же быстро, как ведущий узел может объединить набор действительных транзакций в запись. Валидаторы обрабатывают эти записи задолго до того, как придет время голосовать за их действительность. При оптимистичной обработке транзакций фактически отсутствует задержка между временем получения последней записи и моментом, когда узел может голосовать. В случае, если консенсус <strong>не</strong> достигнут, узел просто откатывает свое состояние. Этот метод оптимистической обработки был представлен в 1981 году и получил название <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.65.4735">Оптимистический контроль параллелизма</a>. Его можно применить к архитектуре блокчейна, где кластер голосует за хэш, представляющий полную книгу до некоторой <em>блоковой высоты</em>. В Solana это реализовано тривиально с использованием хеша PoH последней записи.</p>
<h2 id="otnoshenie-k-vdf">Отношение к VDF</h2>
<p>Техника Proof of History была впервые описана для использования в блокчейне Соланой в ноябре 2017 года. В июне следующего года аналогичная техника была описана в Стэнфорде и названа [функция проверяемой задержки](https://eprint.iacr. org/2018/601.pdf) или <em>VDF</em>.</p>
<p>Желательным свойством VDF является очень быстрое время проверки. Подход Соланы к проверке функции задержки пропорционален времени, затраченному на ее создание. Разделенный на 4000-ядерный графический процессор, он достаточно быстр для нужд Соланы, но если вы спросите авторов упомянутой выше статьи, они могут сказать вам ([и имеют](https://github.com/solana-labs/ solana/issues/388)), что подход Соланы алгоритмически медленный и его не следует называть VDF. Мы утверждаем, что термин VDF должен представлять категорию проверяемых функций задержки, а не просто подмножество с определенными характеристиками производительности. Пока это не будет решено, Solana, скорее всего, продолжит использовать термин PoH для своего VDF для конкретного приложения.</p>
<p>Другое различие между PoH и VDF заключается в том, что VDF используется только для отслеживания продолжительности. Хэш-цепочка PoH, с другой стороны, включает в себя хэши любых данных, наблюдаемых приложением. Эти данные — палка о двух концах. С одной стороны, данные «доказывают историю» — данные наверняка существовали до хэшей после них. С другой стороны, это означает, что приложение может манипулировать цепочкой хеширования, изменяя время хеширования данных. Таким образом, цепочка PoH не может служить хорошим источником случайности, тогда как VDF без этих данных может. [Алгоритм вращения лидера] Соланы (synchronization.md#leader-rotation), например, получен только из <em>height</em> VDF, а не из его хэша на этой высоте.</p>
<h2 id="sviaz-s-mekhanizmami-konsensusa">Связь с механизмами консенсуса</h2>
<p>Proof of History не является механизмом консенсуса, но он используется для улучшения производительности консенсуса Proof of Stake Соланы. Он также используется для повышения производительности протоколов плоскости данных.</p>
<h2 id="podrobnee-o-proof-of-history">Подробнее о Proof of History</h2>
<ul>
<li><a href="https://medium.com/solana-labs/proof-of-history-explained-by-a-water-clock-e682183417b8">аналогия с водяными часами</a></li>
<li><a href="https://medium.com/solana-labs/proof-of-history-a-clock-for-blockchain-cf47a61a9274">Обзор доказательства истории</a></li>
</ul>










<script src="https://giscus.app/client.js"
    data-repo="dudochkin-victor&#x2F;dudochkin-victor.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkzNzgwNTYx"
    data-category="General"
    data-category-id="DIC_kwDOADmv0c4CAhvj"
    data-mapping="pathname"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async>
</script>



        </div>

        
        
    </main>

    
    <footer>
        <small class="subtext">
            <a href="https://angular-rust.github.io">Dudochkin Victor</a> © 2021
        </small>
    </footer>
    
</body>
<script>
    function highlightNav(heading) {
        let pathname = location.pathname;
        document.querySelectorAll(".toc a").forEach((item) => {
            item.classList.remove("active");
        });
        document.querySelector(".toc a[href$='" + pathname + "#" + heading + "']").classList.add("active");
    }

    let currentHeading = "";
    window.onscroll = function () {
        let h = document.querySelectorAll("h1,h2,h3,h4,h5,h6");
        let elementArr = [];

        h.forEach(item => {
            if (item.id !== "") {
                elementArr[item.id] = item.getBoundingClientRect().top;
            }
        });
        elementArr.sort();
        for (let key in elementArr) {
            if (!elementArr.hasOwnProperty(key)) {
                continue;
            }
            if (elementArr[key] > 0 && elementArr[key] < 300) {
                if (currentHeading !== key) {
                    highlightNav(key);
                    currentHeading = key;
                }
                break;
            }
        }
    }
</script>

</html>
