<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Подтверждение блокировки | Dudochkin Victor </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="google-site-verification" content="Kepqb6k6uptlwngnHbBVJmqQtwNW8zfHyQBbTXLYAgA" />
    <meta name="yandex-verification" content="8e8bc73c2566b473" />
    <style>
    :root {
        /* Primary theme color */
        /* --primary-color: #121A26; */
        --primary-color: #0f1419;
        /* Primary theme text color */
        /* --primary-text-color: #121A26; */
        --primary-text-color: #0f1419;
        /* Primary theme link color */
        --primary-link-color: #053961;
        /* Secondary color: the background body color */
        --secondary-color: #F0F0F0;
        --secondary-text-color: #1C2834;
        /* Highlight text color of table of content */
        --toc-highlight-text-color: #053961;
    }
</style>
    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-47MMPLLY44"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-47MMPLLY44');
    </script>
    

    
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
    
        ym('87064264', "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/87064264" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    
    
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="/mdl.min.css">
    <link rel="stylesheet" href="https://dudochkin-victor.github.io/style.css">
    
    
</head>

<body>
    
<header class="box-shadow">
    

<a href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;">
    <div class="logo">
        <img src="https://dudochkin-victor.github.io/ferris.png" alt="logo">
        Dudochkin Victor
    </div>
</a>

<nav>
    <!-- 
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;showcases&#x2F;">Showcases</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;changelog&#x2F;">Changelog</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;about&#x2F;">About</a>
     -->

    
        
        <a class="nav-item subtitle-text" href="&#x2F;solana&#x2F;">Solana</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;edgeware&#x2F;">Edgeware</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;blog&#x2F;">Блог</a>
        
        <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;github.com&#x2F;dudochkin-victor">Github</a>
        
    
</nav>

</header>

 
    <main>
        
        
        
        
        
        <div class="toc">
            <div class="toc-sticky">
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/block-confirmation/#tekushchii-dizain">Текущий дизайн</a>
                </div>
                
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/block-confirmation/#problemy"><small>- Проблемы</small></a>
                </div>
                
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/block-confirmation/#predlagaemyi-dizain">Предлагаемый дизайн</a>
                </div>
                
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/block-confirmation/#iznachal-no-net-kross-blochnogo-sostoianiia"><small>- Изначально нет кросс-блочного состояния</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/block-confirmation/#zavershenie-i-vyplaty"><small>- Завершение и выплаты</small></a>
                </div>
                
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/block-confirmation/#problemy-1">Проблемы</a>
                </div>
                
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/block-confirmation/#onchein-golosovanie"><small>- Ончейн-голосование</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/block-confirmation/#vliianie-golosovaniia-na-predydushchie-bloki"><small>- Влияние голосования на предыдущие блоки</small></a>
                </div>
                
                
                
            </div>
        </div>
        
        

        <div class="content text">
            
<h1>Подтверждение блокировки</h1>

<p>Валидатор голосует за хэш PoH для двух целей. Во-первых, голосование указывает на то, что реестр действителен до этого момента времени. Во-вторых, поскольку на заданной высоте может существовать много действительных ответвлений, голосование также указывает на исключительную поддержку этого ответвления. В этом документе описывается только первое. Последнее описано в <a href="../implemented-proposals/tower-bft/">Tower BFT</a>.</p>
<h2 id="tekushchii-dizain">Текущий дизайн</h2>
<p>Чтобы начать голосование, валидатор сначала регистрирует учетную запись, на которую он будет отправлять свои голоса. Затем он отправляет голоса на этот счет. Голосование содержит высоту тика блока, по которому оно голосует. Учетная запись хранит 32 самые высокие высоты.</p>
<h3 id="problemy">Проблемы</h3>
<ul>
<li>
<p>Только валидатор умеет находить свои голоса напрямую.</p>
<p>Другие компоненты, например, тот, который вычисляет время подтверждения, необходимо встроить в код валидатора. Код валидатора запрашивает у банка все счета, принадлежащие программе голосования.</p>
</li>
<li>
<p>Бюллетени для голосования не содержат хеша PoH. Валидатор голосует только за то, что он наблюдал произвольный блок на какой-то высоте.</p>
</li>
<li>
<p>Бюллетени для голосования не содержат хэш состояния банка. Без этого хэша нет доказательств того, что валидатор выполнил транзакции и подтвердил отсутствие двойных трат.</p>
</li>
</ul>
<h2 id="predlagaemyi-dizain">Предлагаемый дизайн</h2>
<h3 id="iznachal-no-net-kross-blochnogo-sostoianiia">Изначально нет кросс-блочного состояния</h3>
<p>В момент создания блока лидер должен добавить в реестр транзакцию NewBlock с количеством токенов, которое представляет собой вознаграждение за проверку.
По сути, это инкрементная мультиподписная транзакция, которая отправляет токены из майнингового пула валидаторам. В учетной записи должно быть достаточно места для сбора голосов, необходимых для достижения квалифицированного большинства. Когда валидатор наблюдает за транзакцией NewBlock, у него есть возможность отправить голосование, включающее хэш его состояния реестра (состояние банка). Как только у учетной записи будет достаточно голосов, программа голосования должна распределить токены по валидаторам, что приведет к удалению учетной записи.</p>
<h4 id="vremia-podtverzhdeniia-registratsii">Время подтверждения регистрации</h4>
<p>Банку необходимо знать о программе голосования. После каждой транзакции он должен проверять, является ли это транзакцией голосования, и если да, то проверять состояние этой учетной записи. Если транзакция привела к достижению квалифицированного большинства, она должна регистрировать время, прошедшее с момента отправки транзакции NewBlock.</p>
<h3 id="zavershenie-i-vyplaty">Завершение и выплаты</h3>
<p><a href="../implemented-proposals/tower-bft/">Tower BFT</a> — это предлагаемый алгоритм выбора форка. Предлагается отложить выплаты майнерам до тех пор, пока стек голосов валидатора не достигнет определенной глубины, после чего откат становится экономически нецелесообразным. Таким образом, программа голосования может реализовать Tower BFT. Инструкции по голосованию должны ссылаться на глобальную учетную запись Tower, чтобы она могла отслеживать состояние перекрестной блокировки.</p>
<h2 id="problemy-1">Проблемы</h2>
<h3 id="onchein-golosovanie">Ончейн-голосование</h3>
<p>Использование программ и учетных записей для реализации этого немного утомительно. Самое сложное — выяснить, сколько места выделить в NewBlock. Двумя переменными являются <em>активный набор</em> и доли этих валидаторов. Если мы посчитаем активный набор на момент отправки NewBlock, количество валидаторов, для которых нужно выделить место, известно заранее. Однако если мы позволим новым валидаторам голосовать за старые блоки, нам понадобится способ динамического распределения пространства.</p>
<p>Аналогично по духу, если лидер кэширует ставки во время NewBlock, программе голосования не нужно взаимодействовать с банком при обработке голосов. Если мы этого не сделаем, у нас есть возможность позволить ставкам плавать до тех пор, пока не будет отправлено голосование. Валидатор мог бы сослаться на свой собственный счет для ставок, но это было бы текущее значение счета, а не значение счета последнего завершенного состояния банка. В настоящее время банк не предлагает средств для привязки счетов к определенным моментам времени.</p>
<h3 id="vliianie-golosovaniia-na-predydushchie-bloki">Влияние голосования на предыдущие блоки</h3>
<p>Подразумевает ли голосование по одной высоте голосование по всем блокам более низких высот этой вилки? Если это произойдет, нам понадобится способ поиска учетных записей всех блоков, которые еще не достигли абсолютного большинства. В противном случае валидатор может отправить голоса всем блокам явно, чтобы получить вознаграждение за блок.</p>










<script src="https://giscus.app/client.js"
    data-repo="dudochkin-victor&#x2F;dudochkin-victor.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkzNzgwNTYx"
    data-category="General"
    data-category-id="DIC_kwDOADmv0c4CAhvj"
    data-mapping="pathname"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async>
</script>



        </div>

        
        
    </main>

    
    <footer>
        <small class="subtext">
            <a href="https://angular-rust.github.io">Dudochkin Victor</a> © 2021
        </small>
    </footer>
    
</body>
<script>
    function highlightNav(heading) {
        let pathname = location.pathname;
        document.querySelectorAll(".toc a").forEach((item) => {
            item.classList.remove("active");
        });
        document.querySelector(".toc a[href$='" + pathname + "#" + heading + "']").classList.add("active");
    }

    let currentHeading = "";
    window.onscroll = function () {
        let h = document.querySelectorAll("h1,h2,h3,h4,h5,h6");
        let elementArr = [];

        h.forEach(item => {
            if (item.id !== "") {
                elementArr[item.id] = item.getBoundingClientRect().top;
            }
        });
        elementArr.sort();
        for (let key in elementArr) {
            if (!elementArr.hasOwnProperty(key)) {
                continue;
            }
            if (elementArr[key] > 0 && elementArr[key] < 300) {
                if (currentHeading !== key) {
                    highlightNav(key);
                    currentHeading = key;
                }
                break;
            }
        }
    }
</script>

</html>
