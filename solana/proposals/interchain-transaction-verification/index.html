<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Межсетевая проверка транзакций | Dudochkin Victor </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="google-site-verification" content="Kepqb6k6uptlwngnHbBVJmqQtwNW8zfHyQBbTXLYAgA" />
    <meta name="yandex-verification" content="8e8bc73c2566b473" />
    <style>
    :root {
        /* Primary theme color */
        /* --primary-color: #121A26; */
        --primary-color: #0f1419;
        /* Primary theme text color */
        /* --primary-text-color: #121A26; */
        --primary-text-color: #0f1419;
        /* Primary theme link color */
        --primary-link-color: #053961;
        /* Secondary color: the background body color */
        --secondary-color: #F0F0F0;
        --secondary-text-color: #1C2834;
        /* Highlight text color of table of content */
        --toc-highlight-text-color: #053961;
    }
</style>
    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-47MMPLLY44"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-47MMPLLY44');
    </script>
    

    
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
    
        ym('87064264', "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/87064264" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    
    
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="/mdl.min.css">
    <link rel="stylesheet" href="https://dudochkin-victor.github.io/style.css">
    
    
</head>

<body>
    
<header class="box-shadow">
    

<a href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;">
    <div class="logo">
        <img src="https://dudochkin-victor.github.io/ferris.png" alt="logo">
        Dudochkin Victor
    </div>
</a>

<nav>
    <!-- 
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;showcases&#x2F;">Showcases</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;changelog&#x2F;">Changelog</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;about&#x2F;">About</a>
     -->

    
        
        <a class="nav-item subtitle-text" href="&#x2F;solana&#x2F;">Solana</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;edgeware&#x2F;">Edgeware</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;blog&#x2F;">Блог</a>
        
        <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;github.com&#x2F;dudochkin-victor">Github</a>
        
    
</nav>

</header>

 
    <main>
        
        
        
        
        
        <div class="toc">
            <div class="toc-sticky">
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/interchain-transaction-verification/#problema">Проблема</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/interchain-transaction-verification/#predlozhennoe-reshenie">Предложенное решение</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/interchain-transaction-verification/#terminologiia">Терминология</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/interchain-transaction-verification/#usluga">Услуга</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/interchain-transaction-verification/#vypolnenie">Выполнение</a>
                </div>
                
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/interchain-transaction-verification/#dvigatel-spv"><small>- Двигатель СПВ</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/interchain-transaction-verification/#programma-spv"><small>- Программа SPV</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/interchain-transaction-verification/#zapros-podtverzhdeniia"><small>- Запрос подтверждения</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/interchain-transaction-verification/#zaprosit-knigu"><small>- Запросить книгу</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/interchain-transaction-verification/#dokazatel-stvo"><small>- Доказательство</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/interchain-transaction-verification/#klient"><small>- Клиент</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/interchain-transaction-verification/#dokazatel-stvo-1"><small>- Доказательство</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/proposals/interchain-transaction-verification/#khranilishche-zagolovkov"><small>- Хранилище заголовков</small></a>
                </div>
                
                
                
            </div>
        </div>
        
        

        <div class="content text">
            
<h1>Межсетевая проверка транзакций</h1>

<h2 id="problema">Проблема</h2>
<p>Межсетевые приложения не новы для экосистемы цифровых активов; на самом деле, даже небольшие централизованные биржи по-прежнему категорически затмевают все приложения с одной цепочкой, вместе взятые, с точки зрения пользователей и объема. Они имеют огромные оценки и потратили годы на эффективную оптимизацию своих основных продуктов для широкого круга конечных пользователей. Однако их основные операции сосредоточены вокруг механизмов, которые требуют, чтобы их пользователи в одностороннем порядке доверяли им, как правило, практически без обращения за помощью или защиты от случайной потери. Это привело к тому, что более широкая экосистема цифровых активов была раздроблена по сетевым линиям, потому что решения по функциональной совместимости обычно:</p>
<ul>
<li>Технически сложны для полной реализации</li>
<li>Создание нестабильных структур стимулирования в масштабе сети</li>
<li>Требовать последовательного и высокого уровня сотрудничества между заинтересованными сторонами</li>
</ul>
<h2 id="predlozhennoe-reshenie">Предложенное решение</h2>
<p>Простая проверка платежей (SPV) — это общий термин для ряда различных методологий, используемых легкими клиентами в большинстве крупных сетей блокчейнов для проверки аспектов состояния сети без необходимости полного хранения и обслуживания самой цепочки. В большинстве случаев это означает полагаться на форму хэш-дерева для предоставления доказательства присутствия данной транзакции в определенном блоке путем сравнения с корневым хэшем в заголовке этого блока или его эквивалентом. Это позволяет легкому клиенту или кошельку достичь вероятностного уровня уверенности в отношении событий в сети с минимальным доверием, требуемым в отношении сетевых узлов.</p>
<p>Традиционно процесс сборки и проверки этих доказательств осуществляется вне цепочки узлами, кошельками или другими клиентами, но он также предлагает потенциальный механизм проверки состояния между цепочками. Однако, перемещая возможность проверки доказательств SPV в цепочку в качестве смарт-контракта, используя при этом архивные свойства, присущие цепочке блоков, можно создать систему для программного обнаружения и проверки транзакций в других сетях без участия любого типа. доверенный оракул или сложный многоэтапный механизм консенсуса. Эта концепция широко применима к любой сети с механизмом SPV и даже может работать в двустороннем порядке на других платформах смарт-контрактов, открывая возможность дешевой и быстрой передачи стоимости между цепочками, не полагаясь на залог, хеш-блоки или доверенных посредников.</p>
<p>Выбор в пользу хорошо зарекомендовавших себя и стабильных в развитии механизмов, которые уже являются общими для всех основных блокчейнов, позволяет решениям по совместимости на основе SPV быть значительно проще, чем организованные многоэтапные подходы. Как часть этого, они избавляются от необходимости в широко согласованных межсетевых стандартах связи и крупных многосторонних организациях, которые пишут их в пользу набора дискретных сервисов на основе контрактов, которые могут быть легко использованы контрактами вызывающих абонентов через общий формат абстракции. Это заложит основу для широкого спектра приложений и контрактов, способных взаимодействовать в разнообразной и каждой растущей платформенной экосистеме.</p>
<h2 id="terminologiia">Терминология</h2>
<p>Программа SPV — клиентский интерфейс для межсетевой системы SPV, управляет ролями участников. SPV Engine — проверяет доказательства транзакций, подмножество программы SPV. Клиент — вызывающий абонент программы SPV, как правило, другой контракт solana. Доказывающая сторона — Сторона, которая создает доказательства для транзакций и представляет их в Программу SPV. Доказательство транзакции — создано Provers, содержит доказательство Меркла, транзакцию и ссылку на блок-заголовок. Merkle Proof — базовое доказательство SPV, подтверждающее наличие транзакции в определенном блоке. Заголовок блока — представляет основные параметры и относительное положение данного блока. Доказательный запрос - Заказ, размещенный клиентом для проверки транзакции(ей) доказывающими. Хранилище заголовков — структура данных для хранения и ссылок на диапазоны заголовков блоков в доказательствах. Запрос клиента — транзакция от клиента к Программе SPV для инициирования создания запроса подтверждения. Дочерняя учетная запись — учетная запись Solana, принадлежащая другой учетной записи контракта, без собственного закрытого ключа.</p>
<h2 id="usluga">Услуга</h2>
<p>Программы SPV работают как контракты, развернутые в сети Solana, и поддерживают тип общедоступной торговой площадки для доказательств SPV, которая позволяет любой стороне отправлять как запросы на доказательства, так и сами доказательства для проверки в ответ на запросы. В любой момент времени будет активным несколько экземпляров программы SPV, по крайней мере один для каждой подключенной внешней сети и, возможно, несколько экземпляров для каждой сети. Экземпляры программы SPV будут относительно согласованными в своем высокоуровневом API и наборах функций с некоторыми различиями между валютными платформами (биткойн, лайткойн) и платформами смарт-контрактов из-за возможности проверки изменений состояния сети помимо простых транзакций. В любом случае, независимо от сети, программа SPV полагается на внутренний компонент, называемый механизмом SPV, для обеспечения проверки без сохранения состояния фактических доказательств SPV, на основе которых построены функции и API более высокого уровня, ориентированные на клиента. Движок SPV требует конкретной сетевой реализации, но позволяет легко расширить более крупную межсетевую экосистему любой командой, которая решит выполнить эту реализацию и поместить ее в стандартную программу SPV для развертывания.</p>
<p>Для целей запроса подтверждения запрашивающая сторона называется клиентом программы, который в большинстве, если не во всех случаях, будет другим контрактом Solana. Клиент может отправить запрос, относящийся к конкретной транзакции, или включить более широкий фильтр, который может применяться к любому из диапазона параметров транзакции, включая ее входы, выходы и сумму. Например, клиент может отправить запрос на любую транзакцию, отправленную с заданного адреса A на адрес B, с суммой X через определенное время. Эта структура может использоваться в ряде приложений, таких как проверка конкретного предполагаемого платежа в случае атомарного свопа или обнаружение движения залоговых активов для кредита.</p>
<p>После отправки клиентского запроса, при условии, что он успешно проверен, программа SPV создает учетную запись подтверждения запроса для отслеживания хода выполнения запроса. Доказывающие используют учетную запись, чтобы указать запрос, который они намереваются заполнить, в доказательствах, которые они отправляют для проверки, после чего программа SPV проверяет эти доказательства и в случае успеха сохраняет их в данных учетной записи запроса. Клиенты могут отслеживать статус своих запросов и просматривать любые применимые транзакции вместе со своими доказательствами, запрашивая данные учетной записи учетной записи запроса. В будущих итерациях, когда Solana будет поддерживать этот процесс, этот процесс будет упрощен за счет публикации событий контрактами, а не с требованием процесса опроса, как описано.</p>
<h2 id="vypolnenie">Выполнение</h2>
<p>Механизм Solana Inter-chain SPV состоит из следующих компонентов и участников:</p>
<h3 id="dvigatel-spv">Двигатель СПВ</h3>
<p>Контракт, развернутый на Солане, который без сохранения состояния проверяет доказательства SPV для вызывающего абонента. Он принимает в качестве аргументов для проверки:</p>
<ul>
<li>
<p>Доказательство SPV в правильном формате блокчейна, связанного с программой.</p>
</li>
<li>
<p>Ссылка \ (s ) на соответствующие заголовки блоков, чтобы сравнить это доказательство с</p>
</li>
<li>
<p>Необходимые параметры сделки для проверки</p>
<p>Если рассматриваемое доказательство успешно проверено, программа SPV сохраняет доказательство этой проверки в учетной записи запроса, которое может быть сохранено вызывающей стороной в данных своей учетной записи или обработано иным образом по мере необходимости. Программы SPV также предоставляют утилиты и структуры, используемые для представления и проверки заголовков, транзакций, хэшей и т. д. по цепочке.</p>
</li>
</ul>
<h3 id="programma-spv">Программа SPV</h3>
<p>Контракт, развернутый на Solana, который координирует и выступает посредником во взаимодействии между клиентами и доказывающими, а также управляет проверкой запросов, заголовков, доказательств и т. д. Это основная точка доступа для клиентских контрактов для доступа к межцепочке. Механизм СПВ. Он предлагает следующие основные функции:</p>
<ul>
<li>
<p>Отправить запрос на доказательство - позволяет клиенту разместить запрос на конкретное доказательство или набор доказательств.</p>
</li>
<li>
<p>Cancel Proof Request - позволяет клиенту аннулировать ожидающий запрос</p>
</li>
<li>
<p>Заполнить запрос подтверждения - используется доказывающими для отправки на проверку доказательства, соответствующего заданному запросу подтверждения.</p>
<p>Программа SPV поддерживает общедоступный список действительных ожидающих запросов на подтверждение в данных своей учетной записи в интересах доказывающих, которые контролируют его и прилагают ссылки на целевые запросы к предоставленным ими доказательствам.</p>
</li>
</ul>
<h3 id="zapros-podtverzhdeniia">Запрос подтверждения</h3>
<p>Сообщение, отправляемое Клиентом механизму SPV, обозначающее запрос на подтверждение конкретной транзакции или набора транзакций. Proof Requests может либо вручную указать определенную транзакцию по ее хэшу, либо выбрать отправку фильтра, который соответствует нескольким транзакциям или классам транзакций. Например, фильтр, соответствующий «любой транзакции с адреса xxx по адресу yyy», может использоваться для обнаружения выплаты долга или расчета по межсетевому свопу. Аналогичным образом фильтр, соответствующий «любой транзакции с адреса xxx», может использоваться договором о кредитовании или выпуске синтетических токенов для отслеживания и реагирования на изменения в обеспечении. Запросы подтверждения отправляются с оплатой, которая выплачивается контрактом на механизм SPV соответствующему Проверщику после проверки подтверждения, соответствующего этому запросу.</p>
<h3 id="zaprosit-knigu">Запросить книгу</h3>
<p>Общедоступный список действительных открытых запросов на подтверждение, доступных для заполнения пруверами или для отмены клиентами. Примерно аналогично книге ордеров на бирже, но с одним типом листинга, а не с двумя отдельными сторонами. Он хранится в данных учетной записи программы SPV.</p>
<h3 id="dokazatel-stvo">Доказательство</h3>
<p>Доказательство наличия данной транзакции в рассматриваемой цепочке блоков. Доказательства охватывают как фактическое доказательство Меркла, так и ссылки(s) на цепочку действительных последовательных заголовков блоков. Они составляются и представляются испытателями в соответствии со спецификациями общедоступных запросов на подтверждение, размещенных в книге запросов программой SPV. После проверки они сохраняются в данных учетной записи соответствующего запроса подтверждения, которые могут использоваться Клиентом для отслеживания состояния запроса.</p>
<h3 id="klient">Клиент</h3>
<p>Инициатор запроса на подтверждение транзакции. Клиентами чаще всего являются другие контракты в составе приложений или конкретных финансовых продуктов, таких как кредиты, свопы, условное депонирование и т. д. Клиент в любом заданном цикле процесса проверки первоначально отправляет ClientRequest, который сообщает параметры и комиссию, и в случае успешной проверки приводит к создание учетной записи Proof Request программой SPV. Клиент также может отправить CancelRequest со ссылкой на активный запрос подтверждения, чтобы обозначить его как недействительный для целей предоставления подтверждения.</p>
<h3 id="dokazatel-stvo-1">Доказательство</h3>
<p>Податель доказательства, который заполняет запрос доказательства. Доказывающие отслеживают книгу запросов программы SPV на наличие невыполненных запросов на подтверждение и генерируют соответствующие доказательства, которые они отправляют в программу SPV для проверки. Если доказательство принято, плата, связанная с рассматриваемым Запросом на подтверждение, выплачивается Доказывающему. Доказывающие обычно работают как узлы Solana Blockstreamer, которые также имеют доступ к узлу Биткойн, который они используют для создания доказательств и доступа к заголовкам блоков.</p>
<h3 id="khranilishche-zagolovkov">Хранилище заголовков</h3>
<p>Структура данных на основе учетной записи, используемая для поддержки заголовков блоков с целью включения в представленные доказательства путем ссылки на учетную запись хранилища заголовков. хранилища заголовков могут поддерживаться независимыми объектами, поскольку проверка цепочки заголовков является компонентом механизма проверки проверки программы SPV. Сборы, выплачиваемые Proof Requests Provers, распределяются между отправителем самого доказательства merkle и хранилищем заголовков, на которое ссылается представленное доказательство. Из-за текущей невозможности увеличить уже выделенную емкость данных учетной записи, вариант использования требует структуры данных, которая может неограниченно расти без повторной балансировки. Суб-аккаунты — это аккаунты, принадлежащие программе SPV, без собственных закрытых ключей, которые используются для хранения путем выделения блокировщиков для данных их аккаунтов. Возможны несколько потенциальных подходов к реализации системы хранения заголовков:</p>
<p>Хранить заголовки в субаккаунтах программы, проиндексированных по публичному адресу:</p>
<ul>
<li>Каждая суб-учетная запись содержит один заголовок и имеет открытый ключ, соответствующий хэшу блока.</li>
<li>Требуется столько же просмотров данных учетной записи, сколько подтверждений для каждой проверки.</li>
<li>Ограничение на количество подтверждений (15-20) через максимальный потолок данных транзакции</li>
<li>Отсутствие дублирования отдельных заголовков в масштабах всей сети.</li>
</ul>
<p>Связанный список нескольких субаккаунтов, хранящих заголовки:</p>
<ul>
<li>Поддерживать последовательный индекс учетных записей хранения, много заголовков на учетную запись хранения</li>
<li>Максимум 2 поиска данных учетной записи для &gt; 99,9% проверок \ (1 для большинства )</li>
<li>Компактный последовательный формат адреса данных позволяет любое количество подтверждений и быстрый поиск</li>
<li>Облегчает неэффективное дублирование заголовков в масштабах всей сети.</li>
</ul>










<script src="https://giscus.app/client.js"
    data-repo="dudochkin-victor&#x2F;dudochkin-victor.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkzNzgwNTYx"
    data-category="General"
    data-category-id="DIC_kwDOADmv0c4CAhvj"
    data-mapping="pathname"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async>
</script>



        </div>

        
        
    </main>

    
    <footer>
        <small class="subtext">
            <a href="https://angular-rust.github.io">Dudochkin Victor</a> © 2021
        </small>
    </footer>
    
</body>
<script>
    function highlightNav(heading) {
        let pathname = location.pathname;
        document.querySelectorAll(".toc a").forEach((item) => {
            item.classList.remove("active");
        });
        document.querySelector(".toc a[href$='" + pathname + "#" + heading + "']").classList.add("active");
    }

    let currentHeading = "";
    window.onscroll = function () {
        let h = document.querySelectorAll("h1,h2,h3,h4,h5,h6");
        let elementArr = [];

        h.forEach(item => {
            if (item.id !== "") {
                elementArr[item.id] = item.getBoundingClientRect().top;
            }
        });
        elementArr.sort();
        for (let key in elementArr) {
            if (!elementArr.hasOwnProperty(key)) {
                continue;
            }
            if (elementArr[key] > 0 && elementArr[key] < 300) {
                if (currentHeading !== key) {
                    highlightNav(key);
                    currentHeading = key;
                }
                break;
            }
        }
    }
</script>

</html>
