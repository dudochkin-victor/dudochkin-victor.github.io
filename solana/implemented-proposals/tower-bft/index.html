<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Tower BFT | Dudochkin Victor </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="google-site-verification" content="Kepqb6k6uptlwngnHbBVJmqQtwNW8zfHyQBbTXLYAgA" />
    <meta name="yandex-verification" content="8e8bc73c2566b473" />
    <style>
    :root {
        /* Primary theme color */
        /* --primary-color: #121A26; */
        --primary-color: #0f1419;
        /* Primary theme text color */
        /* --primary-text-color: #121A26; */
        --primary-text-color: #0f1419;
        /* Primary theme link color */
        --primary-link-color: #053961;
        /* Secondary color: the background body color */
        --secondary-color: #F0F0F0;
        --secondary-text-color: #1C2834;
        /* Highlight text color of table of content */
        --toc-highlight-text-color: #053961;
    }
</style>
    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-47MMPLLY44"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-47MMPLLY44');
    </script>
    

    
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
    
        ym('87064264', "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/87064264" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    
    
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="/mdl.min.css">
    <link rel="stylesheet" href="https://dudochkin-victor.github.io/style.css">
    
    
</head>

<body>
    
<header class="box-shadow">
    

<a href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;">
    <div class="logo">
        <img src="https://dudochkin-victor.github.io/ferris.png" alt="logo">
        Dudochkin Victor
    </div>
</a>

<nav>
    <!-- 
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;showcases&#x2F;">Showcases</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;changelog&#x2F;">Changelog</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;about&#x2F;">About</a>
     -->

    
        
        <a class="nav-item subtitle-text" href="&#x2F;solana&#x2F;">Solana</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;edgeware&#x2F;">Edgeware</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;blog&#x2F;">Блог</a>
        
        <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;github.com&#x2F;dudochkin-victor">Github</a>
        
    
</nav>

</header>

 
    <main>
        
        
        
        
        
        <div class="toc">
            <div class="toc-sticky">
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/tower-bft/#vremia">Время</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/tower-bft/#blokirovki">Блокировки</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/tower-bft/#algoritm">Алгоритм</a>
                </div>
                
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/tower-bft/#otkat"><small>- Откат</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/tower-bft/#rubka-i-nagrady"><small>- Рубка и награды</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/tower-bft/#stoimost-otkata"><small>- Стоимость отката</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/tower-bft/#porogi"><small>- Пороги</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/tower-bft/#parametry-algoritma"><small>- Параметры алгоритма</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/tower-bft/#svobodnyi-vybor"><small>- Свободный выбор</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/tower-bft/#zhadnyi-vybor-parallel-nykh-forkov"><small>- Жадный выбор параллельных форков</small></a>
                </div>
                
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/tower-bft/#soprotivlenie-poh-asic">Сопротивление PoH ASIC</a>
                </div>
                
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/tower-bft/#tsenzura-asic"><small>- Цензура ASIC</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/tower-bft/#otkat-asic"><small>- Откат ASIC</small></a>
                </div>
                
                
                
            </div>
        </div>
        
        

        <div class="content text">
            
<h1>Tower BFT</h1>

<p>Этот проект описывает алгоритм <em>Tower BFT</em> Соланы. Он решает следующие проблемы:</p>
<ul>
<li>Некоторые форки могут быть не приняты подавляющим большинством кластера, и избирателям необходимо восстановиться после голосования по таким форкам.</li>
<li>За многие вилки могут голосовать разные избиратели, и каждый голосующий может видеть свой набор вилок, за которые можно голосовать. Выбранные ответвления должны в конечном итоге сойтись для кластера.</li>
<li>Голосование на основе вознаграждения связано с риском. Избиратели должны иметь возможность настроить степень риска, на который они идут.</li>
<li><a href="tower-bft.md#cost-of-rollback">Стоимость отката</a> должна быть вычисляемой. Это важно для клиентов, которые полагаются на какую-то измеримую форму согласованности. Затраты на нарушение согласованности должны быть вычислимыми и увеличиваться сверхлинейно для более старых голосов.</li>
<li>Скорости ASIC различаются между узлами, и злоумышленники могут использовать ASICS Proof of History, которые намного быстрее, чем остальная часть кластера. Консенсус должен быть устойчивым к атакам, использующим изменчивость скорости Proof of History ASIC.</li>
</ul>
<p>Для краткости этот дизайн предполагает, что один голосующий с долей развернут как отдельный валидатор в кластере.</p>
<h2 id="vremia">Время</h2>
<p>Кластер Solana генерирует источник времени с помощью функции проверяемой задержки, которую мы называем <a href="../cluster/synchronization/">Proof of History</a>.</p>
<p>Proof of History используется для создания детерминированного кругового расписания для всех активных лидеров. В любой момент времени только 1 лидер, который может быть вычислен из самой книги, может предложить ответвление. Для получения дополнительной информации см. <a href="../cluster/fork-generation/">генерация вилки</a> и <a href="../cluster/leader-rotation/">ротация лидера</a>.</p>
<h2 id="blokirovki">Блокировки</h2>
<p>Цель блокировки — заставить валидатора зафиксировать упущенную выгоду для определенного форка. Блокировки измеряются в слотах и ​​поэтому представляют собой вынужденную задержку в реальном времени, которую валидатор должен выждать, прежде чем нарушить обязательство по форку.</p>
<p>Валидаторы, которые нарушают локауты и голосуют за расходящийся форк в рамках локаута, должны быть наказаны. Предлагаемое наказание состоит в том, чтобы сократить долю валидатора, если кластеру может быть доказано одновременное голосование в рамках блокировки для форка, не являющегося потомком.</p>
<h2 id="algoritm">Алгоритм</h2>
<p>Основная идея этого подхода заключается в суммировании консенсусных голосов и двойных локаутах. Каждый голос в стеке является подтверждением форка. Каждая подтвержденная вилка является предком вилки над ней. Каждое голосование имеет «блокировку» в единицах слотов, прежде чем валидатор сможет отправить голосование, которое не содержит подтвержденного форка в качестве предка.</p>
<p>Когда голос добавляется в стек, блокировки всех предыдущих голосов в стеке удваиваются (подробнее об этом в <a href="tower-bft.md#%D0%9E%D1%82%D0%BA%D0%B0%D1%82">Откат</a>). С каждым новым голосом валидатор переводит предыдущие голоса в постоянно увеличивающуюся блокировку. При 32 голосах мы можем считать, что голосование находится в состоянии «максимальной блокировки», любые голоса с блокировкой, равной или превышающей «1&lt;&lt;32», удаляются из очереди (FIFO). Удаление из очереди голосования является триггером для вознаграждения. Если срок действия голоса истекает до того, как он будет исключен из очереди, он и все голоса над ним удаляются (LIFO) из стека голосов. Валидатор должен начать перестраивать стек с этой точки.</p>
<h3 id="otkat">Откат</h3>
<p>Прежде чем голосование будет помещено в стек, все голоса, ведущие к голосованию с более низким временем блокировки, чем новое голосование, извлекаются. После отката локауты не удваиваются, пока валидатор не догонит высоту отката голосов.</p>
<p>Например, стек голосования со следующим состоянием:</p>
<table><thead><tr><th align="right">vote</th><th align="right">vote time</th><th align="right">lockout</th><th align="right">lock expiration time</th></tr></thead><tbody>
<tr><td align="right">4</td><td align="right">4</td><td align="right">2</td><td align="right">6</td></tr>
<tr><td align="right">3</td><td align="right">3</td><td align="right">4</td><td align="right">7</td></tr>
<tr><td align="right">2</td><td align="right">2</td><td align="right">8</td><td align="right">10</td></tr>
<tr><td align="right">1</td><td align="right">1</td><td align="right">16</td><td align="right">17</td></tr>
</tbody></table>
<p><em>Vote 5</em> находится в момент времени 9, и результирующее состояние</p>
<table><thead><tr><th align="right">vote</th><th align="right">vote time</th><th align="right">lockout</th><th align="right">lock expiration time</th></tr></thead><tbody>
<tr><td align="right">5</td><td align="right">9</td><td align="right">2</td><td align="right">11</td></tr>
<tr><td align="right">2</td><td align="right">2</td><td align="right">8</td><td align="right">10</td></tr>
<tr><td align="right">1</td><td align="right">1</td><td align="right">16</td><td align="right">17</td></tr>
</tbody></table>
<p><em>Голосование 6</em> в момент времени 10</p>
<table><thead><tr><th align="right">vote</th><th align="right">vote time</th><th align="right">lockout</th><th align="right">lock expiration time</th></tr></thead><tbody>
<tr><td align="right">6</td><td align="right">10</td><td align="right">2</td><td align="right">12</td></tr>
<tr><td align="right">5</td><td align="right">9</td><td align="right">4</td><td align="right">13</td></tr>
<tr><td align="right">2</td><td align="right">2</td><td align="right">8</td><td align="right">10</td></tr>
<tr><td align="right">1</td><td align="right">1</td><td align="right">16</td><td align="right">17</td></tr>
</tbody></table>
<p>В момент времени 10 новые голоса догнали предыдущие голоса. Но срок действия <em>vote 2</em> истекает в 10, поэтому, когда применяется <em>vote 7</em> в момент 11, голоса, включая и выше <em>vote 2</em>, будут извлечены.</p>
<table><thead><tr><th align="right">vote</th><th align="right">vote time</th><th align="right">lockout</th><th align="right">lock expiration time</th></tr></thead><tbody>
<tr><td align="right">7</td><td align="right">11</td><td align="right">2</td><td align="right">13</td></tr>
<tr><td align="right">1</td><td align="right">1</td><td align="right">16</td><td align="right">17</td></tr>
</tbody></table>
<p>Блокировка для первого голоса не увеличится с 16 до тех пор, пока в стеке не будет 5 голосов.</p>
<h3 id="rubka-i-nagrady">Рубка и награды</h3>
<p>Валидаторы должны быть вознаграждены за выбор форка, который остальная часть кластера выбирала как можно чаще. Это хорошо согласуется с получением вознаграждения, когда стек голосов заполнен и самый старый голос необходимо исключить из очереди. Таким образом, вознаграждение должно генерироваться за каждое успешное удаление из очереди.</p>
<h3 id="stoimost-otkata">Стоимость отката</h3>
<p>Стоимость отката <em>fork A</em> определяется как стоимость времени блокировки для валидатора для подтверждения любого другого форка, который не включает <em>fork A</em> в качестве предка.</p>
<p><strong>Экономическая завершенность</strong> <em>форка A</em> может быть рассчитана как потеря всех вознаграждений от отката <em>форка A</em> и его потомков, плюс альтернативная стоимость вознаграждения из-за экспоненциально растущего локаута голосов, которые подтвердили <em>форк A</em>.</p>
<h3 id="porogi">Пороги</h3>
<p>Каждый валидатор может независимо установить порог приверженности кластера к форку до того, как этот валидатор зафиксирует форк. Например, при индексе стека голосования 7 блокировка составляет 256 единиц времени. Валидатор может отказать в голосовании и позволить истечь срокам действия голосов 0-7, если голосование с индексом 7 не имеет более 50% обязательств в кластере. Это позволяет каждому валидатору независимо контролировать степень риска, связанного с форком. Совершение форков с более высокой частотой позволит валидатору заработать больше вознаграждений.</p>
<h3 id="parametry-algoritma">Параметры алгоритма</h3>
<p>Необходимо настроить следующие параметры:</p>
<ul>
<li>Количество голосов в стеке до исключения из очереди (32).</li>
<li>Скорость роста локаутов в стеке (2x).</li>
<li>Запуск блокировки по умолчанию (2).</li>
<li>Пороговая глубина для минимального выделения кластера перед фиксацией ветки (8).</li>
<li>Минимальный размер обязательства кластера при пороговой глубине (50%+).</li>
</ul>
<h3 id="svobodnyi-vybor">Свободный выбор</h3>
<p>«Свободный выбор» — это неисполнимое действие валидатора. Протокол не может кодировать и применять эти действия, поскольку каждый валидатор может изменять код и корректировать алгоритм. Валидатор, который максимизирует самовознаграждение по всем возможным вариантам будущего, должен вести себя таким образом, чтобы система была стабильной, а локальный жадный выбор должен приводить к жадному выбору по всем возможным вариантам будущего. Набор валидаторов, принимающих участие в выборах для нарушения протокола, должен быть связан своим весом доли с отказом в обслуживании. Два варианта выхода для валидатора:</p>
<ul>
<li>валидатор может опередить предыдущего валидатора в виртуальной генерации и отправить параллельный форк</li>
<li>валидатор может приостановить голосование, чтобы понаблюдать за несколькими разветвлениями перед голосованием</li>
</ul>
<p>В обоих случаях у валидатора в кластере есть несколько ответвлений, из которых можно одновременно выбирать, даже если каждое ответвление представляет собой разную высоту. В обоих случаях протокол не может определить, является ли поведение валидатора преднамеренным или нет.</p>
<h3 id="zhadnyi-vybor-parallel-nykh-forkov">Жадный выбор параллельных форков</h3>
<p>При оценке нескольких форков каждый валидатор должен использовать следующие правила:</p>
<ol>
<li>Вилки должны удовлетворять правилу <em>Threshold</em>.</li>
<li>Выберите ветку, которая максимизирует общее время блокировки кластера для всех веток-предков.</li>
<li>Выберите вилку с наибольшей комиссией за транзакцию кластера.</li>
<li>Выберите последний форк с точки зрения PoH.</li>
</ol>
<p>Плата за транзакцию кластера — это плата, которая вносится в майнинговый пул, как описано в разделе <a href="staking-rewards/">Вознаграждения за стейкинг</a>.</p>
<h2 id="soprotivlenie-poh-asic">Сопротивление PoH ASIC</h2>
<p>Голоса и блокировки растут в геометрической прогрессии, в то время как скорость ASIC линейна. Есть два возможных вектора атаки с использованием более быстрой ASIC.</p>
<h3 id="tsenzura-asic">Цензура ASIC</h3>
<p>Злоумышленник создает параллельный форк, который опережает предыдущих лидеров, пытаясь подвергнуть их цензуре. Форк, предложенный этим злоумышленником, будет доступен одновременно со следующим доступным лидером. Чтобы узлы могли выбрать эту вилку, она должна удовлетворять правилу <em>Greedy Choice</em>.</p>
<ol>
<li>Форк должен иметь равное количество голосов для форка-предка.</li>
<li>Вилка не может быть настолько далекой, чтобы привести к просроченным голосам.</li>
<li>Форк должен иметь большую комиссию за транзакцию кластера.</li>
</ol>
<p>Затем эта атака ограничивается цензурой сборов предыдущих лидеров и отдельных транзакций. Но он не может остановить кластер или уменьшить набор валидаторов по сравнению с параллельным форком. Плата за цензуру ограничивается платой за доступ, поступающей лидерам, но не валидаторам.</p>
<h3 id="otkat-asic">Откат ASIC</h3>
<p>Злоумышленник создает параллельную вилку из более старого блока, чтобы попытаться откатить кластер. В этой атаке одновременный форк конкурирует с форками, за которые уже проголосовали. Эта атака ограничена экспоненциальным ростом локаутов.</p>
<ul>
<li>1 голос блокирует 2 слота. Параллельная вилка должна быть как минимум на 2 слота впереди и производиться в 1 слоте. Поэтому требуется ASIC в 2 раза быстрее.</li>
<li>2 голоса имеют блокировку 4х слотов. Параллельная вилка должна быть как минимум на 4 слота впереди и производиться в 2 слотах. Поэтому требуется ASIC в 2 раза быстрее.</li>
<li>3 голоса имеют блокировку 8 слотов. Параллельная вилка должна быть как минимум на 8 слотов впереди и производиться в 3 слотах. Поэтому требуется ASIC в 2,6 раза быстрее.</li>
<li>10 голосов имеют блокировку 1024 слотов. 1024/10 или в 102,4 раза быстрее ASIC.</li>
<li>20 голосов имеют блокировку 2^20 слотов. 2^20/20, или в 52 428,8 раз быстрее ASIC.</li>
</ul>










<script src="https://giscus.app/client.js"
    data-repo="dudochkin-victor&#x2F;dudochkin-victor.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkzNzgwNTYx"
    data-category="General"
    data-category-id="DIC_kwDOADmv0c4CAhvj"
    data-mapping="pathname"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async>
</script>



        </div>

        
        
    </main>

    
    <footer>
        <small class="subtext">
            <a href="https://angular-rust.github.io">Dudochkin Victor</a> © 2021
        </small>
    </footer>
    
</body>
<script>
    function highlightNav(heading) {
        let pathname = location.pathname;
        document.querySelectorAll(".toc a").forEach((item) => {
            item.classList.remove("active");
        });
        document.querySelector(".toc a[href$='" + pathname + "#" + heading + "']").classList.add("active");
    }

    let currentHeading = "";
    window.onscroll = function () {
        let h = document.querySelectorAll("h1,h2,h3,h4,h5,h6");
        let elementArr = [];

        h.forEach(item => {
            if (item.id !== "") {
                elementArr[item.id] = item.getBoundingClientRect().top;
            }
        });
        elementArr.sort();
        for (let key in elementArr) {
            if (!elementArr.hasOwnProperty(key)) {
                continue;
            }
            if (elementArr[key] > 0 && elementArr[key] < 300) {
                if (currentHeading !== key) {
                    highlightNav(key);
                    currentHeading = key;
                }
                break;
            }
        }
    }
</script>

</html>
