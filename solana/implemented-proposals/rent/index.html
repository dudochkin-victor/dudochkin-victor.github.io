<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Аренда | Dudochkin Victor </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="google-site-verification" content="Kepqb6k6uptlwngnHbBVJmqQtwNW8zfHyQBbTXLYAgA" />
    <meta name="yandex-verification" content="8e8bc73c2566b473" />
    <style>
    :root {
        /* Primary theme color */
        /* --primary-color: #121A26; */
        --primary-color: #0f1419;
        /* Primary theme text color */
        /* --primary-text-color: #121A26; */
        --primary-text-color: #0f1419;
        /* Primary theme link color */
        --primary-link-color: #053961;
        /* Secondary color: the background body color */
        --secondary-color: #F0F0F0;
        --secondary-text-color: #1C2834;
        /* Highlight text color of table of content */
        --toc-highlight-text-color: #053961;
    }
</style>
    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-47MMPLLY44"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-47MMPLLY44');
    </script>
    

    
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
    
        ym('87064264', "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/87064264" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    
    
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="/mdl.min.css">
    <link rel="stylesheet" href="https://dudochkin-victor.github.io/style.css">
    
    
</head>

<body>
    
<header class="box-shadow">
    

<a href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;">
    <div class="logo">
        <img src="https://dudochkin-victor.github.io/ferris.png" alt="logo">
        Dudochkin Victor
    </div>
</a>

<nav>
    <!-- 
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;showcases&#x2F;">Showcases</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;changelog&#x2F;">Changelog</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;about&#x2F;">About</a>
     -->

    
        
        <a class="nav-item subtitle-text" href="&#x2F;solana&#x2F;">Solana</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;edgeware&#x2F;">Edgeware</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;blog&#x2F;">Блог</a>
        
        <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;github.com&#x2F;dudochkin-victor">Github</a>
        
    
</nav>

</header>

 
    <main>
        
        
        
        
        
        <div class="toc">
            <div class="toc-sticky">
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/rent/#dvukhurovnevyi-rezhim-arendy">Двухуровневый режим аренды</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/rent/#sroki-sbora-arendnoi-platy">Сроки сбора арендной платы</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/rent/#fakticheskaia-obrabotka-sbora-arendnoi-platy">Фактическая обработка сбора арендной платы</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/rent/#rekomendatsii-po-dizainu">Рекомендации по дизайну</a>
                </div>
                
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/rent/#obosnovanie-tekushchego-dizaina"><small>- Обоснование текущего дизайна</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/rent/#spetsial-naia-kollektsiia"><small>- Специальная коллекция</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/solana/implemented-proposals/rent/#sistemnaia-instruktsiia-po-sboru-arendnoi-platy"><small>- Системная инструкция по сбору арендной платы</small></a>
                </div>
                
                
                
            </div>
        </div>
        
        

        <div class="content text">
            
<h1>Аренда</h1>

<p>Учетные записи в Solana могут иметь контролируемое владельцем состояние (<code>Account::data</code>), которое отделено от баланса учетной записи (<code>Account::lamports</code>). Поскольку валидаторы в сети должны поддерживать рабочую копию этого состояния в памяти, сеть взимает плату за потребление этого ресурса, основанную на времени и пространстве, также известную как рента.</p>
<h2 id="dvukhurovnevyi-rezhim-arendy">Двухуровневый режим аренды</h2>
<p>Счета, которые поддерживают минимальный баланс, эквивалентный 2 годам арендных платежей, освобождаются. <em>2 года</em> взяты из того факта, что стоимость оборудования падает на 50% каждые 2 года, и в результате сходимости из-за того, что они представляют собой геометрический ряд. Со счетов, баланс которых падает ниже этого порога, взимается арендная плата по ставке, указанной в генезисе, в лэмпортах за байт-год. Сеть взимает арендную плату за каждую эпоху в кредит на следующую эпоху, а <code>Account::rent_epoch</code> отслеживает, когда в следующий раз арендная плата должна быть собрана со счета.</p>
<p>В настоящее время стоимость аренды фиксирована при генезисе. Однако ожидается, что он будет динамическим, отражая стоимость базового аппаратного хранилища в то время. Таким образом, обычно ожидается, что цена будет снижаться по мере снижения стоимости оборудования по мере развития технологии.</p>
<h2 id="sroki-sbora-arendnoi-platy">Сроки сбора арендной платы</h2>
<p>Существует два момента сбора арендной платы со счетов: (1) при ссылке на транзакцию, (2) периодически один раз в эпоху. (1) включает транзакцию для создания самой новой учетной записи, и это происходит во время обычной обработки транзакции банком на этапе загрузки. (2) существует для того, чтобы собирать ренту с устаревших аккаунтов, которые вообще не упоминаются в последние эпохи. (2) требует полного сканирования учетных записей и распределяется по эпохам на основе префикса адреса учетной записи, чтобы избежать скачков нагрузки из-за этого сбора арендной платы.</p>
<p>Напротив, сбор арендной платы не применяется к учетным записям, которые напрямую манипулируются любым из процессов бухгалтерского учета на уровне протокола, включая:</p>
<ul>
<li>Само распределение сбора ренты (в противном случае это может привести к рекурсивной обработке сбора ренты)</li>
<li>Распределение вознаграждений за стекинг в начале каждой эпохи (чтобы уменьшить количество обработки в начале новой эпохи)</li>
<li>Распределение комиссии за транзакцию в конце каждого слота</li>
</ul>
<p>Даже если эти процессы выходят за рамки сбора ренты, все управляемые учетные записи в конечном итоге будут обрабатываться механизмом (2).</p>
<h2 id="fakticheskaia-obrabotka-sbora-arendnoi-platy">Фактическая обработка сбора арендной платы</h2>
<p>Арендная плата взимается за время, равное одной эпохе, и учетные записи имеют <code>Account::rent_epoch</code> из <code>current_epoch</code> или <code>current_epoch + 1</code> в зависимости от режима аренды.</p>
<p>Если учетная запись находится в режиме исключения, <code>Account::rent_epoch</code> просто обновляется до <code>current_epoch</code>.</p>
<p>Если учетная запись не освобождена, разница между следующей эпохой и <code>Account::rent_epoch</code> используется для расчета суммы арендной платы, причитающейся с этой учетной записи (через <code>Rent::due()</code>). Любые дробные лампы вычисления усекаются. Арендная плата вычитается из <code>Account::lamports</code>, а <code>Account::rent_epoch</code> обновляется до <code>current_epoch + 1</code> (= следующая эпоха). Если сумма причитающейся арендной платы меньше одного лампорта, в счет не вносятся изменения.</p>
<p>Аккаунты, баланс которых недостаточен для оплаты арендной платы, просто не загружаются.</p>
<p>Часть собранной ренты уничтожается. Остальное распределяется между учетными записями валидаторов в зависимости от веса ставки, а-ля комиссия за транзакцию, в конце каждого слота.</p>
<p>Наконец, сбор арендной платы происходит в соответствии с обновлениями учетной записи на уровне протокола, такими как распределение арендной платы между валидаторами, что означает отсутствие соответствующей транзакции для вычетов арендной платы. Таким образом, сбор арендной платы довольно невидим, его можно только неявно наблюдать по недавней транзакции или заранее определенному времени с учетом префикса адреса учетной записи.</p>
<h2 id="rekomendatsii-po-dizainu">Рекомендации по дизайну</h2>
<h3 id="obosnovanie-tekushchego-dizaina">Обоснование текущего дизайна</h3>
<p>В соответствии с предыдущим дизайном НЕ возможно иметь учетные записи, которые задерживаются, никогда не трогаются и никогда не нужно платить арендную плату. Учетные записи всегда платят арендную плату ровно один раз за каждую эпоху, за исключением учетных записей без арендной платы, sysvar и исполняемых учетных записей.</p>
<p>Это предполагаемый выбор дизайна. В противном случае можно было бы инициировать несанкционированный сбор арендной платы с помощью инструкции «Noop» любым, кто может несправедливо получить прибыль от арендной платы (лидер на данный момент) или сохранить арендную плату с учетом ожидаемых колебаний стоимости аренды.</p>
<p>В качестве еще одного побочного эффекта этого выбора также обратите внимание, что этот периодический сбор арендной платы фактически заставляет валидаторов оптимистично не хранить устаревшие учетные записи в холодном хранилище и экономить на стоимости хранения, что неблагоприятно для владельцев учетных записей и может привести к тому, что транзакции на них будут задерживаться дольше. чем другие. С другой стороны, это не позволяет злоумышленникам создавать значительное количество мусорных учетных записей, обременяя валидаторов.</p>
<p>Как общее следствие такого дизайна, все учетные записи хранятся одинаково как рабочий набор валидатора с одинаковыми характеристиками производительности, что отражает единую структуру ценообразования арендной платы.</p>
<h3 id="spetsial-naia-kollektsiia">Специальная коллекция</h3>
<p>Рассматривался сбор арендной платы по мере необходимости \ (т. е. всякий раз, когда учетные записи загружались / открывались ). Проблемы с таким подходом:</p>
<ul>
<li>
<p>учетные записи, загруженные как «только кредит» для транзакции, вполне разумно могут ожидать, что будет причитаться арендная плата, но они не будут доступны для записи во время любой такой транзакции.</p>
</li>
<li>
<p>желателен механизм &quot;ходить в кусты&quot; (т.е. искать аккаунты, которые должны платить арендную плату), чтобы аккаунты, которые загружаются нечасто, получали халяву</p>
</li>
</ul>
<h3 id="sistemnaia-instruktsiia-po-sboru-arendnoi-platy">Системная инструкция по сбору арендной платы</h3>
<p>Рассматривался сбор арендной платы с помощью системной инструкции, поскольку это, естественно, распределяло бы ренту между активными и взвешенными узлами и могло осуществляться постепенно. Тем не мение:</p>
<ul>
<li>это отрицательно сказалось бы на пропускной способности сети</li>
<li>это потребовало бы специального оформления исполняющей средой, так как эта инструкция может списывать счета с владельцев, не являющихся владельцами SystemProgram</li>
<li>кто-то должен будет выдавать транзакции</li>
</ul>










<script src="https://giscus.app/client.js"
    data-repo="dudochkin-victor&#x2F;dudochkin-victor.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkzNzgwNTYx"
    data-category="General"
    data-category-id="DIC_kwDOADmv0c4CAhvj"
    data-mapping="pathname"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async>
</script>



        </div>

        
        
    </main>

    
    <footer>
        <small class="subtext">
            <a href="https://angular-rust.github.io">Dudochkin Victor</a> © 2021
        </small>
    </footer>
    
</body>
<script>
    function highlightNav(heading) {
        let pathname = location.pathname;
        document.querySelectorAll(".toc a").forEach((item) => {
            item.classList.remove("active");
        });
        document.querySelector(".toc a[href$='" + pathname + "#" + heading + "']").classList.add("active");
    }

    let currentHeading = "";
    window.onscroll = function () {
        let h = document.querySelectorAll("h1,h2,h3,h4,h5,h6");
        let elementArr = [];

        h.forEach(item => {
            if (item.id !== "") {
                elementArr[item.id] = item.getBoundingClientRect().top;
            }
        });
        elementArr.sort();
        for (let key in elementArr) {
            if (!elementArr.hasOwnProperty(key)) {
                continue;
            }
            if (elementArr[key] > 0 && elementArr[key] < 300) {
                if (currentHeading !== key) {
                    highlightNav(key);
                    currentHeading = key;
                }
                break;
            }
        }
    }
</script>

</html>
