<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Толчок к стабилизации GAT | Dudochkin Victor </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="google-site-verification" content="Kepqb6k6uptlwngnHbBVJmqQtwNW8zfHyQBbTXLYAgA" />
    <meta name="yandex-verification" content="8e8bc73c2566b473" />
    <style>
    :root {
        /* Primary theme color */
        /* --primary-color: #121A26; */
        --primary-color: #0f1419;
        /* Primary theme text color */
        /* --primary-text-color: #121A26; */
        --primary-text-color: #0f1419;
        /* Primary theme link color */
        --primary-link-color: #053961;
        /* Secondary color: the background body color */
        --secondary-color: #F0F0F0;
        --secondary-text-color: #1C2834;
        /* Highlight text color of table of content */
        --toc-highlight-text-color: #053961;
    }
</style>
    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-47MMPLLY44"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-47MMPLLY44');
    </script>
    

    
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
    
        ym('87064264', "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/87064264" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    
    
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="/mdl.min.css">
    <link rel="stylesheet" href="https://dudochkin-victor.github.io/style.css">
    
    
</head>

<body>
    
<header class="box-shadow">
    

<a href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;">
    <div class="logo">
        <img src="https://dudochkin-victor.github.io/ferris.png" alt="logo">
        Dudochkin Victor
    </div>
</a>

<nav>
    <!-- 
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;showcases&#x2F;">Showcases</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;changelog&#x2F;">Changelog</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;about&#x2F;">About</a>
     -->

    
        
        <a class="nav-item subtitle-text" href="&#x2F;solana&#x2F;">Solana</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;edgeware&#x2F;">Edgeware</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;blog&#x2F;">Блог</a>
        
        <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;github.com&#x2F;dudochkin-victor">Github</a>
        
    
</nav>

</header>

 
    <main>
        
        
        
        
        
        <div class="toc">
            <div class="toc-sticky">
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/the-push-for-gats-stabilization/#tolchok-k-stabilizatsii-gat">Толчок к стабилизации GAT</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/the-push-for-gats-stabilization/#tak-chto-zhe-takoe-gat">Так что же такое GAT?</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/the-push-for-gats-stabilization/#pochemu-na-eto-potrebovalos-tak-mnogo-vremeni">Почему на это потребовалось так много времени?</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/the-push-for-gats-stabilization/#kakie-ogranicheniia-sushchestvuiut-v-nastoiashchee-vremia">Какие ограничения существуют в настоящее время?</a>
                </div>
                
                
            </div>
        </div>
        
        

        <div class="content text">
            
<h1>Толчок к стабилизации GAT</h1>

<p><a href="https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html">Перевод</a> | Автор оригинала: Jack Huey</p>
<h2 id="tolchok-k-stabilizatsii-gat">Толчок к стабилизации GAT</h2>
<p>С чего начать, с чего начать ...</p>
<p>Начнем с того, что скажем: это очень интересный пост. Некоторые люди, читающие это, будут чрезвычайно взволнованы; некоторые не будут знать, что такое GAT (общие связанные типы); другие могут быть в недоумении. RFC для этой функции был открыт в апреле 2016 года (и объединился примерно через полтора года). Фактически, этот RFC даже предшествует дженерикам const (MVP которого недавно был стабилизирован). Не позволяйте этому обмануть вас: это мощная функция; и реакция на проблему отслеживания на Github, возможно, должна дать вам представление о ее популярности (это самая популярная проблема в репозитории Rust): реакции GAT</p>
<p>Если вы не знакомы с GAT, они позволяют вам определять обобщенные типы типа, времени жизни или константы для связанных типов. Вот так: </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">trait </span><span style="color:#59c2ff;">Foo </span><span>{
</span><span>    </span><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Bar</span><span style="color:#f29668;">&lt;</span><span style="color:#ff7733;">&#39;a</span><span style="color:#f29668;">&gt;</span><span style="color:#bfbab0cc;">;
</span><span>}
</span></code></pre>
<p>Это может показаться разочаровывающим, но позже я более подробно расскажу, почему это действительно мощная функция.</p>
<p>Но пока: что именно происходит? Что ж, спустя почти четыре года после того, как его RFC был объединен, функция generic_associated_types больше не является «неполной».</p>
<p><em>crickets chirping</em></p>
<p>Подожди ... вот и все ?? Ну да! Позже в этом сообщении в блоге я расскажу немного подробнее о том, почему это так важно. Но, короче говоря, в компилятор пришлось внести много изменений, чтобы заставить GAT работать. И хотя остается еще несколько небольших проблем с диагностикой, эта функция наконец-то находится в той области, в которой мы чувствуем себя комфортно, делая ее более не «неполной».</p>
<p>Так что это значит? Что ж, все это на самом деле означает, что когда вы используете эту функцию по ночам, вы больше не будете получать предупреждение «generic_associated_types is incomplete». Однако настоящая причина этого важна: мы хотим стабилизировать эту функцию. Но нам нужна ваша помощь. Нам нужно, чтобы вы протестировали эту функцию, сообщали о проблемах, связанных с обнаруженными вами ошибками, или о возможных улучшениях диагностики. Кроме того, мы хотели бы, чтобы вы просто рассказали нам о некоторых интересных паттернах, которые GAT поддерживает в Zulip!</p>
<p>Не давая обещаний, которые мы не уверены на 100%, мы очень надеемся, что сможем стабилизировать эту функцию в течение следующих нескольких месяцев. Но мы хотим убедиться, что не упускаем явно очевидных ошибок или недостатков. Мы хотим, чтобы стабилизация была плавной.</p>
<p>Хорошо. Уф. Это основная мысль этого поста и самые интересные новости. Но, как я уже сказал ранее, я думаю, что для меня также разумно объяснить, что это за функция, что вы можете с ней делать, а также кое-что из предыстории и как мы сюда попали.</p>
<h2 id="tak-chto-zhe-takoe-gat">Так что же такое GAT?</h2>
<p>__ Примечание: это будет лишь краткий обзор. RFC содержит гораздо больше деталей .__</p>
<p>GAT (общие связанные типы) были первоначально предложены в RFC 1598. Как было сказано ранее, они позволяют вам определять общие типы, время жизни или константы для связанных типов. Если вы знакомы с языками, в которых есть «типы более высокого порядка», тогда вы можете вызывать конструкторы типов GAT для свойств. Возможно, самый простой способ понять, как можно использовать GAT, - это перейти к примеру.</p>
<p>Вот популярный вариант использования: LendingIterator (ранее известный как StreamingIterator): </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">trait </span><span style="color:#59c2ff;">LendingIterator </span><span>{
</span><span>    </span><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Item</span><span style="color:#f29668;">&lt;</span><span style="color:#ff7733;">&#39;a</span><span style="color:#f29668;">&gt; </span><span style="color:#ff7733;">where Self</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">&#39;a</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">next</span><span>&lt;</span><span style="color:#ff7733;">&#39;a</span><span>&gt;(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">&#39;a mut </span><span style="color:#f29718;">self</span><span>) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Option</span><span>&lt;</span><span style="color:#ff7733;">Self</span><span style="color:#f29668;">::</span><span>Item&lt;</span><span style="color:#ff7733;">&#39;a</span><span>&gt;&gt;</span><span style="color:#bfbab0cc;">;
</span><span>}
</span></code></pre>
<p>Давайте рассмотрим одну реализацию этого, гипотетический &lt;[T]&gt;::windows_mut, который позволяет выполнять итерацию через перекрывающиеся изменяемые окна на срезе. Если бы вы сегодня попытались реализовать это с помощью Iterator, например </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">struct </span><span style="color:#59c2ff;">WindowsMut</span><span>&lt;</span><span style="color:#ff7733;">&#39;t</span><span>, T&gt; {
</span><span>    slice</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">&#39;t mut</span><span> [T],
</span><span>    start</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">usize</span><span>,
</span><span>    window_size</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">usize</span><span>,
</span><span>}
</span><span>
</span><span style="color:#ff7733;">impl</span><span>&lt;</span><span style="color:#ff7733;">&#39;t</span><span>, T&gt; Iterator </span><span style="color:#ff7733;">for </span><span style="color:#59c2ff;">WindowsMut</span><span>&lt;</span><span style="color:#ff7733;">&#39;t</span><span>, T&gt; {
</span><span>    </span><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Item </span><span style="color:#f29668;">= &amp;</span><span style="color:#ff7733;">&#39;t mut </span><span>[T]</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">next</span><span>&lt;</span><span style="color:#ff7733;">&#39;a</span><span>&gt;(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">&#39;a mut </span><span style="color:#f29718;">self</span><span>) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Option</span><span>&lt;</span><span style="color:#ff7733;">Self</span><span style="color:#f29668;">::</span><span>Item&gt; {
</span><span>        </span><span style="color:#ff7733;">let</span><span> retval </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>slice[</span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>start</span><span style="color:#f29668;">..</span><span>]</span><span style="color:#f29668;">.</span><span style="color:#f07178;">get_mut</span><span>(</span><span style="color:#f29668;">..</span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>window_size)</span><span style="color:#f29668;">?</span><span style="color:#bfbab0cc;">;
</span><span>        </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>start </span><span style="color:#f29668;">+= </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">;
</span><span>        </span><span style="font-style:italic;color:#39bae6;">Some</span><span>(retval)
</span><span>    }
</span><span>}
</span></code></pre>
<p>тогда вы получите ошибку. </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span>error[</span><span style="color:#f29718;">E0495</span><span>]</span><span style="color:#bfbab0cc;">:</span><span> cannot infer an appropriate lifetime </span><span style="color:#ff7733;">for</span><span> lifetime parameter </span><span style="color:#f29668;">in</span><span> function call due to conflicting requirements
</span><span>  </span><span style="color:#f29668;">-</span><span style="color:#bfbab0cc;">-&gt;</span><span> src</span><span style="color:#f29668;">/</span><span>lib</span><span style="color:#f29668;">.</span><span>rs</span><span style="color:#bfbab0cc;">:</span><span style="color:#f29718;">9</span><span style="color:#bfbab0cc;">:</span><span style="color:#f29718;">22
</span><span>   </span><span style="color:#f29668;">|
</span><span style="color:#f29718;">9  </span><span style="color:#f29668;">|         </span><span style="color:#ff7733;">let</span><span> retval </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>slice[</span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>start</span><span style="color:#f29668;">..</span><span>]</span><span style="color:#f29668;">.</span><span style="color:#f07178;">get_mut</span><span>(</span><span style="color:#f29668;">..</span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>window_size)</span><span style="color:#f29668;">?</span><span style="color:#bfbab0cc;">;
</span><span>   |                      ^^^^^^^^^^^^^^^^^^^^^^^^
</span><span>   </span><span style="color:#f29668;">|
</span><span>note</span><span style="color:#bfbab0cc;">:</span><span> first</span><span style="color:#bfbab0cc;">,</span><span> the lifetime cannot outlive the lifetime `</span><span style="color:#ff7733;">&#39;a</span><span>` </span><span style="color:#f29668;">as</span><span> defined on the method body at </span><span style="color:#f29718;">8</span><span style="color:#bfbab0cc;">:</span><span style="color:#f29718;">13</span><span style="color:#f29668;">...
</span><span>  </span><span style="color:#f29668;">-</span><span style="color:#bfbab0cc;">-&gt;</span><span> src</span><span style="color:#f29668;">/</span><span>lib</span><span style="color:#f29668;">.</span><span>rs</span><span style="color:#bfbab0cc;">:</span><span style="color:#f29718;">8</span><span style="color:#bfbab0cc;">:</span><span style="color:#f29718;">13
</span><span>   </span><span style="color:#f29668;">|
</span><span style="color:#f29718;">8  </span><span style="color:#f29668;">|     </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">next</span><span>&lt;</span><span style="color:#ff7733;">&#39;a</span><span>&gt;(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">&#39;a mut </span><span style="color:#f29718;">self</span><span>) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Option</span><span>&lt;</span><span style="color:#ff7733;">Self</span><span style="color:#f29668;">::</span><span>Item&gt; {
</span><span>   </span><span style="color:#f29668;">|             ^^
</span><span>note</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">...</span><span>so that reference does not outlive borrowed content
</span><span>  </span><span style="color:#f29668;">-</span><span style="color:#bfbab0cc;">-&gt;</span><span> src</span><span style="color:#f29668;">/</span><span>lib</span><span style="color:#f29668;">.</span><span>rs</span><span style="color:#bfbab0cc;">:</span><span style="color:#f29718;">9</span><span style="color:#bfbab0cc;">:</span><span style="color:#f29718;">22
</span><span>   </span><span style="color:#f29668;">|
</span><span style="color:#f29718;">9  </span><span style="color:#f29668;">|         </span><span style="color:#ff7733;">let</span><span> retval </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>slice[</span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>start</span><span style="color:#f29668;">..</span><span>]</span><span style="color:#f29668;">.</span><span style="color:#f07178;">get_mut</span><span>(</span><span style="color:#f29668;">..</span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>window_size)</span><span style="color:#f29668;">?</span><span style="color:#bfbab0cc;">;
</span><span>   |                      ^^^^^^^^^^
</span><span>note</span><span style="color:#bfbab0cc;">:</span><span> but</span><span style="color:#bfbab0cc;">,</span><span> the lifetime must be valid </span><span style="color:#ff7733;">for</span><span> the lifetime `</span><span style="color:#ff7733;">&#39;t</span><span>` </span><span style="color:#f29668;">as</span><span> defined on the </span><span style="color:#ff7733;">impl </span><span style="color:#59c2ff;">at</span><span> 6:6...
</span><span>  --&gt; </span><span style="color:#59c2ff;">src</span><span>/</span><span style="color:#59c2ff;">lib</span><span>.</span><span style="color:#59c2ff;">rs</span><span>:6:6
</span><span>   |
</span><span>6  | </span><span style="color:#59c2ff;">impl</span><span>&lt;</span><span style="color:#ff7733;">&#39;t</span><span>, T</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">&#39;t</span><span>&gt; </span><span style="color:#59c2ff;">Iterator for WindowsMut</span><span>&lt;</span><span style="color:#ff7733;">&#39;t</span><span>, T&gt; {
</span><span>   |      ^^
</span></code></pre>
<p>Короче говоря, эта ошибка, по сути, говорит нам, что для того, чтобы мы могли вернуть ссылку на self.slice, он должен существовать до тех пор, пока 'a, что потребует привязки' a: 't (что мы можем' ') т предоставить). Без этого мы могли бы вызвать next, уже удерживая ссылку на срез, создавая перекрывающиеся изменяемые ссылки. Однако он отлично компилируется, если вы реализовали это с помощью трейта LendingIterator из предыдущего: </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">impl</span><span>&lt;</span><span style="color:#ff7733;">&#39;t</span><span>, T&gt; LendingIterator </span><span style="color:#ff7733;">for </span><span style="color:#59c2ff;">WindowsMut</span><span>&lt;</span><span style="color:#ff7733;">&#39;t</span><span>, T&gt; {
</span><span>    </span><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Item</span><span style="color:#f29668;">&lt;</span><span style="color:#ff7733;">&#39;a</span><span style="color:#f29668;">&gt; </span><span style="color:#ff7733;">where Self</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">&#39;a </span><span style="color:#f29668;">= &amp;</span><span style="color:#ff7733;">&#39;a mut </span><span>[T]</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">next</span><span>&lt;</span><span style="color:#ff7733;">&#39;a</span><span>&gt;(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">&#39;a mut </span><span style="color:#f29718;">self</span><span>) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Option</span><span>&lt;</span><span style="color:#ff7733;">Self</span><span style="color:#f29668;">::</span><span>Item&lt;</span><span style="color:#ff7733;">&#39;a</span><span>&gt;&gt; {
</span><span>        </span><span style="color:#ff7733;">let</span><span> retval </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>slice[</span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>start</span><span style="color:#f29668;">..</span><span>]</span><span style="color:#f29668;">.</span><span style="color:#f07178;">get_mut</span><span>(</span><span style="color:#f29668;">..</span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>window_size)</span><span style="color:#f29668;">?</span><span style="color:#bfbab0cc;">;
</span><span>        </span><span style="font-style:italic;color:#39bae6;">self</span><span style="color:#f29668;">.</span><span>start </span><span style="color:#f29668;">+= </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">;
</span><span>        </span><span style="font-style:italic;color:#39bae6;">Some</span><span>(retval)
</span><span>    }
</span><span>}
</span></code></pre>
<p>В стороне, есть одна вещь, которую следует отметить по поводу этой трэйты и подразумевает, что вам может быть интересно узнать: пункт where Self: 'в Item. Вкратце, это позволяет нам использовать &amp;'a mut [T]; без этого предложения where кто-то может попытаться вернуть Self::Item &lt;'static&gt; и продлить время жизни среза. Мы понимаем, что это иногда вызывает путаницу, и рассматриваем потенциальные альтернативы, например, всегда предполаGATь эту границу или подразумевать ее на основе использования в трейте (см. Этот вопрос). Мы определенно хотели бы услышать здесь о ваших вариантах использования, особенно если предположить, что это ограничение будет помехой.</p>
<p>В качестве другого примера представьте, что вы хотите, чтобы структура была универсальной по указателю на определенный тип. Вы можете написать следующий код: </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">trait </span><span style="color:#59c2ff;">PointerFamily </span><span>{
</span><span>    </span><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Pointer</span><span style="color:#f29668;">&lt;</span><span>T</span><span style="color:#f29668;">&gt;</span><span style="color:#bfbab0cc;">: </span><span>Deref&lt;Target = T&gt;</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">new</span><span>&lt;T&gt;(</span><span style="color:#f29718;">value</span><span style="color:#bfbab0cc;">:</span><span> T) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="color:#ff7733;">Self</span><span style="color:#f29668;">::</span><span>Pointer&lt;T&gt;</span><span style="color:#bfbab0cc;">;
</span><span>}
</span><span>
</span><span style="color:#ff7733;">struct </span><span style="color:#59c2ff;">ArcFamily</span><span style="color:#bfbab0cc;">;
</span><span style="color:#ff7733;">struct </span><span style="color:#59c2ff;">RcFamily</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span style="color:#ff7733;">impl </span><span>PointerFamily </span><span style="color:#ff7733;">for </span><span style="color:#59c2ff;">ArcFamily </span><span>{
</span><span>    </span><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Pointer</span><span style="color:#f29668;">&lt;</span><span>T</span><span style="color:#f29668;">&gt; = </span><span>Arc&lt;T&gt;</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#f29668;">...
</span><span>}
</span><span style="color:#ff7733;">impl </span><span>PointerFamily </span><span style="color:#ff7733;">for </span><span style="color:#59c2ff;">RcFamily </span><span>{
</span><span>    </span><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Pointer</span><span style="color:#f29668;">&lt;</span><span>T</span><span style="color:#f29668;">&gt; = </span><span>Rc&lt;T&gt;</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#f29668;">...
</span><span>}
</span><span>
</span><span style="color:#ff7733;">struct </span><span style="color:#59c2ff;">MyStruct</span><span>&lt;P</span><span style="color:#bfbab0cc;">:</span><span> PointerFamily&gt; {
</span><span>    pointer</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">P</span><span style="color:#f29668;">::</span><span>Pointer&lt;</span><span style="font-style:italic;color:#39bae6;">String</span><span>&gt;,
</span><span>}
</span></code></pre>
<p>Мы не будем вдаваться в подробности здесь, но этот пример хорош тем, что не только подчеркивает использование типов в GAT, но также показывает, что вы все еще можете использовать границы трэйтов, которые вы уже можете использовать для связанных типов. .</p>
<p>Эти два примера лишь поверхностно относятся к шаблонам, поддерживаемым GAT. Если вы найдете что-то особенно интересное или умное, мы будем рады услышать о них на Zulip!</p>
<h2 id="pochemu-na-eto-potrebovalos-tak-mnogo-vremeni">Почему на это потребовалось так много времени?</h2>
<p>Так что же заставило нас потратить почти четыре года, чтобы достичь того, чем мы являемся сейчас? Что ж, трудно выразить словами, насколько существующий решатель трэйтов пришлось изменить и адаптировать; но подумайте вот о чем: какое-то время считалось, что для поддержки GAT нам придется перевести rustc на использование Chalk, потенциального будущего решателя трэйтов, который использует логические предикаты для решения целей трэйтов (хотя, хотя некоторый прогресс был достигнут, это все еще очень экспериментально даже сейчас).</p>
<p>Для справки, вот несколько различных дополнений и изменений в реализации, которые так или иначе способствовали поддержке GAT:</p>
<ul>
<li>Разбор GAT в AST (# 45904)</li>
<li>Разрешение времени жизни в GAT (# 46706)</li>
<li>Начальная работа решателя трэйтов для поддержки продолжительности жизни (# 67160)</li>
<li>Проверка границ проекции (и внесение изменений, допускающих типовые и константные GAT) (# 72788)</li>
<li>Разделение границ проекции и предикатов (# 73905)</li>
<li>Разрешение GAT в путях черт (# 79554)</li>
<li>Частично заменить проверку герметичности вселенными (# 65232)</li>
<li>Перенести проверку на утечку на более поздний этап при поиске трэйтов (# 72493)</li>
<li>Замена связанных переменных в GAT на заполнители при проецировании (# 86993)</li>
</ul>
<p>И чтобы еще больше подчеркнуть работу, приведенную выше: многие из этих PR являются крупными и требуют значительных проектных работ. Есть также несколько более мелких PR. Но мы сделали это. И я просто хочу поздравить всех, кто так или иначе приложил усилия. Ты жжешь.</p>
<h2 id="kakie-ogranicheniia-sushchestvuiut-v-nastoiashchee-vremia">Какие ограничения существуют в настоящее время?</h2>
<p>Итак, теперь начинается то, о чем никто не любит слышать: ограничения. К счастью, в этом случае действительно есть только одно ограничение GAT: трэйты с GAT небезопасны для объектов. Это означает, что вы не сможете сделать что-то вроде </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">takes_iter</span><span>(</span><span style="color:#f29668;">_</span><span>: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> dyn for&lt;</span><span style="color:#ff7733;">&#39;a</span><span>&gt; LendingIterator&lt;Item&lt;</span><span style="color:#ff7733;">&#39;a</span><span>&gt; = </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">&#39;a i32</span><span>&gt;) {}
</span></code></pre>
<p>Самая большая причина для этого решения заключается в том, что еще предстоит немного поработать над дизайном и реализацией, чтобы сделать это действительно пригодным для использования. И хотя это хорошая функция, добавление ее в будущем будет обратно совместимым изменением. Мы считаем, что лучше стабилизировать большинство GAT, а затем вернуться и попытаться решить эту проблему позже, чем блокировать GAT еще дольше. Кроме того, GAT без обеспечения безопасности объектов по-прежнему очень эффективны, поэтому мы мало что теряем, откладывая это.</p>
<p>Как упоминалось ранее в этом посте, остается еще пара проблем с диагностикой. Если вы все же найдете ошибки, пожалуйста, сообщите о проблемах! </p>










<script src="https://giscus.app/client.js"
    data-repo="dudochkin-victor&#x2F;dudochkin-victor.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkzNzgwNTYx"
    data-category="General"
    data-category-id="DIC_kwDOADmv0c4CAhvj"
    data-mapping="pathname"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async>
</script>



        </div>

        
        
    </main>

    
    <footer>
        <small class="subtext">
            <a href="https://angular-rust.github.io">Dudochkin Victor</a> © 2021
        </small>
    </footer>
    
</body>
<script>
    function highlightNav(heading) {
        let pathname = location.pathname;
        document.querySelectorAll(".toc a").forEach((item) => {
            item.classList.remove("active");
        });
        document.querySelector(".toc a[href$='" + pathname + "#" + heading + "']").classList.add("active");
    }

    let currentHeading = "";
    window.onscroll = function () {
        let h = document.querySelectorAll("h1,h2,h3,h4,h5,h6");
        let elementArr = [];

        h.forEach(item => {
            if (item.id !== "") {
                elementArr[item.id] = item.getBoundingClientRect().top;
            }
        });
        elementArr.sort();
        for (let key in elementArr) {
            if (!elementArr.hasOwnProperty(key)) {
                continue;
            }
            if (elementArr[key] > 0 && elementArr[key] < 300) {
                if (currentHeading !== key) {
                    highlightNav(key);
                    currentHeading = key;
                }
                break;
            }
        }
    }
</script>

</html>
