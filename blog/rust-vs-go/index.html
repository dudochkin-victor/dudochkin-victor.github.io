<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Rust против Go | Dudochkin Victor </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="google-site-verification" content="Kepqb6k6uptlwngnHbBVJmqQtwNW8zfHyQBbTXLYAgA" />
    <meta name="yandex-verification" content="8e8bc73c2566b473" />
    <style>
    :root {
        /* Primary theme color */
        /* --primary-color: #121A26; */
        --primary-color: #0f1419;
        /* Primary theme text color */
        /* --primary-text-color: #121A26; */
        --primary-text-color: #0f1419;
        /* Primary theme link color */
        --primary-link-color: #053961;
        /* Secondary color: the background body color */
        --secondary-color: #F0F0F0;
        --secondary-text-color: #1C2834;
        /* Highlight text color of table of content */
        --toc-highlight-text-color: #053961;
    }
</style>
    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-47MMPLLY44"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-47MMPLLY44');
    </script>
    

    
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
    
        ym('87064264', "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/87064264" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    
    
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="/mdl.min.css">
    <link rel="stylesheet" href="https://dudochkin-victor.github.io/style.css">
    
    
</head>

<body>
    
<header class="box-shadow">
    

<a href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;">
    <div class="logo">
        <img src="https://dudochkin-victor.github.io/ferris.png" alt="logo">
        Dudochkin Victor
    </div>
</a>

<nav>
    <!-- 
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;showcases&#x2F;">Showcases</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;changelog&#x2F;">Changelog</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;about&#x2F;">About</a>
     -->

    
        
        <a class="nav-item subtitle-text" href="&#x2F;solana&#x2F;">Solana</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;edgeware&#x2F;">Edgeware</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;blog&#x2F;">Блог</a>
        
        <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;github.com&#x2F;dudochkin-victor">Github</a>
        
    
</nav>

</header>

 
    <main>
        
        
        
        
        
        <div class="toc">
            <div class="toc-sticky">
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#rust-i-go-potriasaiushchie">Rust и Go потрясающие</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#skhodstvo">Сходство</a>
                </div>
                
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#bezopasnost-pamiati"><small>- Безопасность памяти</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#bystrye-kompaktnye-ispolniaemye-faily"><small>- Быстрые компактные исполняемые файлы</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#iazyki-obshchego-naznacheniia"><small>- Языки общего назначения</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#pragmatichnyi-stil-programmirovaniia"><small>- Прагматичный стиль программирования</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#masshtabnoe-razvitie"><small>- Масштабное развитие</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#tak-o-chem-zhe-ves-etot-shum"><small>- Так о чем же весь этот шум?</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#proizvoditel-nost"><small>- Производительность</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#prostota"><small>- Простота</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#funktsii"><small>- Функции</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#parallelizm"><small>- Параллелизм</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#bezopasnost"><small>- Безопасность</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#masshtab"><small>- Масштаб</small></a>
                </div>
                
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#razlichiia">Различия</a>
                </div>
                
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#vyvoz-musora"><small>- Вывоз мусора</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#blizko-k-metallu"><small>- Близко к металлу</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#dolzhen-li-go-byt-bystree"><small>- Должен ли Go быть быстрее</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#pravil-nost"><small>- Правильность</small></a>
                </div>
                
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#vyvod">Вывод</a>
                </div>
                
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#sravnenie-koda-rust-i-go"><small>- Сравнение кода Rust и Go</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#nachinaia"><small>- Начиная</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/rust-vs-go/#blagodarnosti"><small>- Благодарности</small></a>
                </div>
                
                
                
            </div>
        </div>
        
        

        <div class="content text">
            
<h1>Rust против Go</h1>

<p><a href="https://bitfieldconsulting.com/golang/rust-vs-go">Перевод</a> | Автор оригинала: John Arundel</p>
<p><img src="/imgs/posts/e2f481ed_01.png" alt="Rust vs Go" /></p>
<p>Что лучше, Rust или Go? Какой язык выбрать для следующего проекта и почему? Как они соотносятся в таких областях, как производительность, простота, безопасность, функции, масштабирование и параллелизм? Что у них общего и чем они принципиально различаются? Давайте выясним это в дружественном и беспристрастном сравнении Rust и Golang.</p>
<h2 id="rust-i-go-potriasaiushchie">Rust и Go потрясающие</h2>
<p>Во-первых, действительно важно сказать, что и Go, и Rust - отличные языки программирования. Они современные, мощные, широко распространенные и предлагают отличные характеристики. Возможно, вы читали статьи и сообщения в блогах, цель которых - убедить вас, что Go лучше, чем Rust, или наоборот. Но это действительно бессмысленно; каждый язык программирования представляет собой набор компромиссов. Каждый язык оптимизирован для разных задач, поэтому ваш выбор языка должен определяться тем, что вам подходит, и проблемами, которые вы хотите решить с его помощью.</p>
<p>В этой статье я постараюсь дать краткий обзор того, где, на мой взгляд, Go - идеальный выбор, а где Rust - лучшая альтернатива. Я также попытаюсь дать представление о сущности обоих языков (Tao of Go и Rust, если хотите).</p>
<p>Хотя они очень разные по синтаксису и стилю, Rust и Go являются первоклассными инструментами для создания программного обеспечения. С учетом сказанного, давайте подробнее рассмотрим эти два языка.</p>
<h2 id="skhodstvo">Сходство</h2>
<p>У Rust и Go много общего, и это одна из причин, по которой их часто упоминают вместе. Каковы общие цели обоих языков?</p>
<p>Rust - это низкоуровневый многопарадигмальный язык программирования со статической типизацией, ориентированный на безопасность и производительность. —Гинтс Дрейманис
Go - это язык программирования с открытым исходным кодом, который упрощает создание простого, надежного и эффективного программного обеспечения. —Golang.org</p>
<h3 id="bezopasnost-pamiati">Безопасность памяти</h3>
<p>И Go, и Rust относятся к группе современных языков программирования, приоритетом которых является безопасность памяти. За многие десятилетия использования старых языков, таких как C и C++, стало ясно, что одной из основных причин ошибок и уязвимостей системы безопасности является небезопасный или неправильный доступ к памяти. Rust и Go решают эту проблему по-разному, но оба стремятся быть умнее и безопаснее, чем другие языки в отношении управления памятью, и помочь вам писать правильные и эффективные программы.</p>
<h3 id="bystrye-kompaktnye-ispolniaemye-faily">Быстрые компактные исполняемые файлы</h3>
<p>Оба они являются скомпилированными языками, что означает, что ваши программы транслируются непосредственно в исполняемый машинный код, так что вы можете развернуть свою программу как единый двоичный файл; В отличие от интерпретируемых языков, таких как Python и Ruby, вам не нужно распространять интерпретатор и множество библиотек и зависимостей вместе с вашей программой, что является большим плюсом. Это также делает программы Rust и Go чрезвычайно быстрыми по сравнению с интерпретируемыми языками.</p>
<h3 id="iazyki-obshchego-naznacheniia">Языки общего назначения</h3>
<p>Rust и Go также являются мощными масштабируемыми языками программирования общего назначения, которые можно использовать для разработки всех видов современного программного обеспечения, от веб-приложений до распределенных микросервисов или от встроенных микроконтроллеров до мобильных приложений. Оба имеют отличные стандартные библиотеки и процветающую стороннюю экосистему, а также отличную коммерческую поддержку и большую базу пользователей. Оба они существуют уже много лет и будут широко использоваться еще долгие годы. Изучение Go или Rust сегодня будет хорошей инвестицией вашего времени и усилий. </p>
<h3 id="pragmatichnyi-stil-programmirovaniia">Прагматичный стиль программирования</h3>
<p>Ни один из них не является преимущественно функциональными языками (например, Scala или Elixir), и ни один из них не является исключительно объектно-ориентированным (например, Java и C#). Вместо этого, хотя и Go, и Rust имеют функции, связанные с функциональным и объектно-ориентированным программированием, это прагматические языки, нацеленные на решение проблем наиболее подходящим способом, а не на принуждение вас к определенному способу работы. (Однако, если вам нравится функциональный стиль программирования, вы найдете для него гораздо больше возможностей в Rust, потому что в Rust гораздо больше возможностей, чем в Go в целом.)</p>
<blockquote>
<p>Мы можем спорить о том, что такое «объектно-ориентированный» язык, но справедливо будет сказать, что стиль объектно-ориентированного программирования, которого ожидают пользователи C++, Java или C#, отсутствует ни в Go, ни в Rust. — Джек Мотт</p>
</blockquote>
<h3 id="masshtabnoe-razvitie">Масштабное развитие</h3>
<p>И Rust, и Go имеют некоторые полезные функции, которые делают их подходящими для программирования в целом, будь то большие команды, большие базы кода или и то, и другое.</p>
<p>Например, в то время как программисты на C годами спорили о том, где поставить скобки и следует ли делать отступы в коде табуляцией или пробелами, и Rust, и Go полностью устраняют такие проблемы с помощью стандартного инструмента форматирования (gofmt для Go, rustfmt для Rust ), который автоматически переписывает ваш код в каноническом стиле. Дело не в том, что этот стиль так хорош сам по себе: это стандартизация, которую ценят программисты на Rust и Go.</p>
<blockquote>
<p>Стиль gofmt никому не нравится, но gofmt нравится всем. — Роб Пайк</p>
</blockquote>
<p>Еще одна область, в которой оба языка имеют высокие оценки, находится в стадии разработки. Оба имеют отличные встроенные высокопроизводительные стандартные инструменты сборки и управления зависимостями; Больше не нужно бороться со сложными системами сборки сторонних разработчиков и изучать новую каждые пару лет.</p>
<blockquote>
<p>Создание кода на Go и Rust, начатое на основе опыта Java и Ruby в начале моей карьеры, казалось мне невыносимым грузом с плеч. Когда я работал в Google, было большим облегчением встретить сервис, написанный на Go, потому что я знал, что его будет легко создать и запустить. То же самое относится и к Rust, хотя я работал над этим только в гораздо меньших масштабах. Я надеюсь, что дни бесконечно настраиваемых систем сборки прошли, и все языки поставляются со своими собственными специализированными инструментами сборки, которые просто работают из коробки. — Сэм Роуз</p>
</blockquote>
<h3 id="tak-o-chem-zhe-ves-etot-shum">Так о чем же весь этот шум?</h3>
<p>Имея все это в виду и видя, что оба языка настолько хорошо спроектированы и мощны, вам может быть интересно, о чем все эти священные войны (я тоже). Почему люди так суетятся из-за «Go против Rust», разгневанных споров в социальных сетях и написания длинных сообщений в блогах о том, что только идиот может использовать Rust, или что Go не является настоящим языком программирования, или что-то еще? Это может помочь им почувствовать себя лучше, но это не совсем поможет вам, как человеку, пытающемуся решить, какой язык использовать для вашего проекта или какой вам следует выучить, чтобы продвинуться в своей карьере программиста. Мудрый человек не делает важный выбор, основываясь на том, кто кричит громче всех.</p>
<p>Давайте продолжим нашу взрослую дискуссию, рассмотрев некоторые области, в которых разумный человек может предпочесть один язык другому. </p>
<h3 id="proizvoditel-nost">Производительность</h3>
<p>Мы сказали, что и Go, и Rust создают чрезвычайно быстрые программы, потому что они скомпилированы в машинный код без использования интерпретатора или виртуальной машины. Однако производительность Rust особенно выдающаяся. Он сравним с C и C++, которые часто считаются наиболее производительными скомпилированными языками, но в отличие от этих более старых языков, он также обеспечивает безопасность памяти и безопасность параллелизма при практически нулевой скорости выполнения. Rust также позволяет создавать сложные абстракции без потери производительности во время выполнения.</p>
<p>Для сравнения: хотя программы Go также работают очень хорошо, Go в первую очередь рассчитан на скорость разработки (включая компиляцию), а не на скорость выполнения. Программисты Go склонны ценить ясный код над быстрым кодом. Компилятор Go также не тратит много времени на создание максимально эффективного машинного кода; он больше заботится о быстрой компиляции большого количества кода. Таким образом, Rust обычно превосходит Go в тестах времени выполнения.</p>
<p>Производительность Rust во время выполнения также последовательна и предсказуема, поскольку он не использует сборку мусора. Сборщик мусора Go очень эффективен, и он оптимизирован так, чтобы сделать паузы в режиме остановки как можно короче (и они становятся короче с каждым новым выпуском Go). Но сборка мусора неизбежно привносит некоторую непредсказуемость в поведение программ, что может быть серьезной проблемой для некоторых приложений, таких как встроенные системы.</p>
<p>Поскольку Rust стремится предоставить программисту полный контроль над базовым оборудованием, можно оптимизировать программы Rust, чтобы они были довольно близки к максимальной теоретической производительности машины. Это делает Rust отличным выбором для областей, где скорость выполнения превосходит все другие соображения, таких как программирование игр, ядра операционной системы, компоненты веб-браузера и системы управления в реальном времени.</p>
<h3 id="prostota">Простота</h3>
<p>Неважно, насколько быстрым является язык программирования, если никто не может понять, как его использовать. Go был сознательно задуман как реакция на постоянно растущую сложность таких языков, как C++; у него очень мало синтаксиса, очень мало ключевых слов и, действительно, мало функций. Это означает, что вам не понадобится много времени, чтобы выучить язык Go до такой степени, что вы сможете писать на нем полезные программы.</p>
<blockquote>
<p>Го невероятно легко научиться. Я знаю, что об этом часто говорят, но я был очень удивлен тем, как быстро я смог работать продуктивно. Благодаря языку, документации и инструментам я писал интересный, коммитируемый код буквально через два дня. — Ранние впечатления от работы программиста на Rust</p>
</blockquote>
<p>Ключевое слово здесь - простота. Конечно, простой - не то же самое, что легко, но маленький простой язык легче выучить, чем большой и сложный. Просто существует не так много разных способов делать что-то, поэтому весь хорошо написанный код Go имеет тенденцию выглядеть одинаково. Легко просто погрузиться в незнакомый сервис и понять, что он делает. </p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span>fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Println</span><span>(</span><span style="color:#c2d94c;">&quot;Gopher&#39;s Diner Breakfast Menu&quot;</span><span>)
</span><span style="color:#ff7733;">for </span><span>dish</span><span style="color:#bfbab0cc;">, </span><span>price </span><span style="color:#f29668;">:= </span><span style="color:#ff7733;">range </span><span>menu {
</span><span>    fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Println</span><span>(dish</span><span style="color:#bfbab0cc;">, </span><span>price)
</span><span>}
</span></code></pre>
<p>(В серии Code Club я делаю именно это: случайным образом выбираю проекты Go из GitHub и исследую их с группой новичков в Go, чтобы увидеть, какую часть кода мы можем понять. Это всегда оказывается больше, чем мы ожидал!)</p>
<p>Хотя основной язык невелик, стандартная библиотека Go очень мощная. Это означает, что ваша кривая обучения также должна будет включать в себя необходимые вам части стандартной библиотеки, а не только синтаксис Go. С другой стороны, перенос функциональности с языка в стандартную библиотеку означает, что вы можете сосредоточиться на изучении только тех библиотек, которые актуальны для вас прямо сейчас.</p>
<p>Go также предназначен для крупномасштабной разработки программного обеспечения с большими кодовыми базами и большими командами. В таких ситуациях важно, чтобы новые разработчики могли как можно быстрее освоиться. По этой причине сообщество Go ценит простые, очевидные, обычные и понятные программы.</p>
<blockquote>
<p>С Go вы быстро справляетесь с задачами. Go - один из самых продуктивных языков, с которыми я когда-либо работал. Мантра:&gt; Решайте реальные проблемы сегодня&gt;. — Матиас Эндлер</p>
</blockquote>
<h3 id="funktsii">Функции</h3>
<blockquote>
<p>Rust поддерживает большую сложность, чем несколько других языков программирования, поэтому с ним можно добиться большего. Например, он поддерживает дженерики. — Деватон</p>
</blockquote>
<p>Rust специально разработан, чтобы включить множество мощных и полезных функций, которые помогают программистам делать максимальную работу с наименьшим количеством кода. Например, функция соответствия в Rust позволяет очень кратко писать гибкую, выразительную логику: </p>
<pre data-lang="rs" style="background-color:#0f1419;color:#bfbab0;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">is_prime</span><span>(</span><span style="color:#f29718;">n</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">u64</span><span>) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="color:#ff7733;">bool </span><span>{
</span><span>    </span><span style="color:#ff7733;">match</span><span> n {
</span><span>        </span><span style="color:#f29718;">0</span><span style="color:#f29668;">...</span><span style="color:#f29718;">1 </span><span style="color:#f29668;">=&gt; </span><span style="color:#f29718;">false</span><span style="color:#bfbab0cc;">,
</span><span>        </span><span style="color:#f29668;">_ =&gt; !</span><span>(</span><span style="color:#f29718;">2</span><span style="color:#f29668;">..</span><span>n)</span><span style="color:#f29668;">.</span><span style="color:#f07178;">any</span><span>(|</span><span style="color:#f29718;">d</span><span>| n </span><span style="color:#f29668;">%</span><span> d </span><span style="color:#f29668;">== </span><span style="color:#f29718;">0</span><span>)</span><span style="color:#bfbab0cc;">,
</span><span>    }
</span><span>}
</span></code></pre>
<p>Поскольку Rust многое делает, это означает, что есть чему поучиться, особенно в начале. Но это нормально: есть чему поучиться на C++ или Java, и вы не получите расширенных функций, которые поставляются с Rust, таких как безопасность памяти. Критиковать Rust за то, что он сложный язык, упускается из виду: он спроектирован так, чтобы быть выразительным, что означает наличие множества функций, а во многих ситуациях именно этого вы и хотите от языка программирования. Конечно, есть кривая обучения, но как только вы начнете с ней работать, все будет в порядке.</p>
<blockquote>
<p>Rust конкурирует за интеллектуальную собственность с C++ и D за программистов, которые готовы принять более сложный синтаксис и семантику (и предположительно более высокие затраты на удобочитаемость) в обмен на максимально возможную производительность. — Дэйв Чейни</p>
</blockquote>
<p>В то время как Rust перенял некоторые функции Go, а Go перенимает некоторые из функций Rust (особенно общие, можно сказать, что Rust многофункционален, а Go - сравнительно легковесен).</p>
<h3 id="parallelizm">Параллелизм</h3>
<p>Большинство языков поддерживают в той или иной форме параллельное программирование (выполнение нескольких задач одновременно), но Go был разработан для этой работы с нуля. Вместо использования потоков операционной системы Go предлагает легкую альтернативу: горутины. Каждая горутина - это независимо выполняющаяся функция Go, которую планировщик Go сопоставляет с одним из потоков ОС, находящихся под его контролем. Это означает, что планировщик может очень эффективно управлять большим количеством параллельных горутин, используя только ограниченное количество потоков ОС.</p>
<p>Следовательно, вы можете запускать миллионы одновременных горутин в одной программе, не создавая серьезных проблем с производительностью. Это делает Go идеальным выбором для одновременных крупномасштабных приложений, таких как веб-серверы и микросервисы.</p>
<p>Go также предлагает быстрые, безопасные и эффективные способы для горутин общаться и обмениваться данными с помощью каналов. Поддержка параллелизма в Go кажется хорошо продуманной, и ею приятно пользоваться. В целом сложно рассуждать о параллельных программах, а создание надежных и правильных параллельных программ - задача для любого языка. Тем не менее, поскольку он был встроен в язык с самого начала, а не второстепенным, параллельное программирование в Go настолько же просто и хорошо интегрировано, насколько это могло бы быть разумно.</p>
<blockquote>
<p>Go упрощает создание хорошо структурированного приложения, которое в полной мере использует преимущества параллелизма при развертывании в виде набора микросервисов. Rust тоже может делать это, но, возможно, немного сложнее. В некоторых отношениях одержимость Rust предотвращением уязвимостей системы безопасности, связанных с памятью, означает, что программисты должны изо всех сил выполнять задачи, которые были бы проще на других языках, включая Go. — Соня Коптьева</p>
</blockquote>
<p>Для сравнения, история параллелизма в Rust очень нова и все еще стабилизируется, но находится в стадии очень активной разработки, так что следите за этой страницей. Например, библиотека Rust rayon предоставляет очень элегантный и легкий способ превращения последовательных вычислений в параллельные.</p>
<blockquote>
<p>Облегченный синтаксис для создания подпрограмм Go и использования каналов - это действительно приятно. Это действительно показывает мощь синтаксиса: такие мелкие детали делают параллельное программирование намного приятнее, чем на других языках. — Ранние впечатления от работы программиста на Rust</p>
</blockquote>
<p>Хотя реализация параллельных программ в Rust может оказаться немного менее простой задачей, это все же возможно, и эти программы могут использовать преимущества гарантий безопасности Rust. Хорошим примером является класс Mutex из стандартной библиотеки: в Go вы можете забыть получить блокировку мьютекса перед доступом к чему-либо, но Rust не позволит вам этого сделать.</p>
<blockquote>
<p>Go ориентирован на параллелизм как первоклассную концепцию. Это не означает, что вы не можете найти аспекты параллелизма, ориентированного на акторов Go, в Rust, но это оставлено как упражнение для программиста. — Дэйв Чейни </p>
</blockquote>
<h3 id="bezopasnost">Безопасность</h3>
<p>Ранее мы видели, что и Go, и Rust по-разному нацелены на предотвращение большого класса распространенных ошибок программирования, связанных с управлением памятью. Но в особенности Rust делает все возможное, чтобы гарантировать, что вы не сможете сделать что-то небезопасное, чего не собирались делать.</p>
<blockquote>
<p>Очень строгий и педантичный компилятор Rust проверяет каждую используемую вами переменную и каждый адрес памяти, на который вы ссылаетесь. Это позволяет избежать возможных состояний гонки данных и информирует вас о неопределенном поведении. Проблемы параллелизма и безопасности памяти принципиально невозможно решить в безопасном подмножестве Rust. - Почему Rust.</p>
</blockquote>
<p>Это сделает программирование на Rust отличным от почти всех других языков, и поначалу это может быть сложно. Но для многих тяжелая работа того стоит.</p>
<blockquote>
<p>Для меня ключевым преимуществом Rust является ощущение, что компилятор стоит за моей спиной и не пропустит ни одной ошибки, которую он мог бы обнаружить (серьезно, иногда это кажется волшебством). — Гжегож Носек</p>
</blockquote>
<p>Многие языки, включая Go, имеют средства, помогающие программистам избегать ошибок, но Rust выводит это на новый уровень, так что потенциально некорректные программы даже не компилируются.</p>
<blockquote>
<p>С Rust у программиста библиотеки есть много инструментов, чтобы предотвратить ошибки пользователей. Rust дает нам возможность сказать, что мы владеем определенной частью данных; Никто другой не может претендовать на право владения, поэтому мы знаем, что ничто другое не сможет его изменить. Я не могу вспомнить время, когда мне когда-либо давали столько инструментов для предотвращения случайного неправильного использования. Это прекрасное чувство. — Сэм Роуз</p>
</blockquote>
<p>«Борьба с программой проверки заимствований» - распространенный синдром для начинающих программистов на Rust, но в большинстве случаев проблемы, которые она обнаруживает, являются настоящими ошибками (или, по крайней мере, потенциальными) в вашем коде. Это может вынудить вас коренным образом перестроить вашу программу, чтобы избежать этих проблем; и это хорошо, когда правильность и надежность - ваш главный приоритет. Какой смысл в языке, который не меняет способ программирования? Уроки безопасности, которые преподает Rust, могут быть полезны и при работе с другими языками.</p>
<blockquote>
<p>Если вы выбираете Rust, обычно вам нужны гарантии, которые предоставляет язык: безопасность от нулевых указателей и гонок данных, предсказуемое поведение во время выполнения и полный контроль над оборудованием. Если вам не нужны какие-либо из этих функций, Rust может оказаться плохим выбором для вашего следующего проекта. Это потому, что за эти гарантии приходится платить: время наращивания мощности. Вам нужно будет отказаться от вредных привычек и изучить новые концепции. Скорее всего, вы будете много бороться со счетчиком займов, когда начнете. — Матиас Эндлер</p>
</blockquote>
<p>Насколько сложной для вас модель программирования Rust, вероятно, будет зависеть от вашего предыдущего опыта работы с другими языками. Программисты Python или Ruby могут счесть это ограничивающим; другие будут в восторге.</p>
<blockquote>
<p>Если вы программист на C или C++, потратившие недели на поиск ошибок, связанных с безопасностью памяти на этих языках, вы по достоинству оцените Rust. «Борьба с проверкой заимствований» превращается в «Компилятор может это обнаружить? Прохладный!&quot; — Гжегож Носек </p>
</blockquote>
<h3 id="masshtab">Масштаб</h3>
<blockquote>
<p>Сегодняшние серверные программы состоят из десятков миллионов строк кода, над ними работают сотни или даже тысячи программистов, и они обновляются буквально каждый день. Go был разработан и разработан, чтобы сделать работу в этой среде более продуктивной. Соображения по дизайну Go включают в себя строгое управление зависимостями, адаптируемость архитектуры программного обеспечения по мере роста системы и устойчивость вне границ между компонентами. — Роб Пайк</p>
</blockquote>
<p>Когда вы работаете над проблемой самостоятельно или в небольших группах, выбор простого или насыщенного языка является делом ваших предпочтений. Но по мере того, как программное обеспечение становится больше и сложнее, а команды становятся больше, различия действительно начинают проявляться. Для больших приложений и распределенных систем скорость выполнения менее важна, чем скорость разработки: преднамеренно минимальный язык, такой как Go, сокращает время наращивания мощности для новых разработчиков и облегчает им работу с большой кодовой базой.</p>
<blockquote>
<p>С Go младшему разработчику легче быть более продуктивным, а разработчику среднего уровня сложнее внедрять хрупкие абстракции, которые вызовут проблемы в будущем. По этим причинам Rust менее привлекателен, чем Go для разработки корпоративного программного обеспечения. — Лорис Кро</p>
</blockquote>
<p>Когда дело доходит до разработки программного обеспечения в целом, ясно, лучше, чем умно. Ограничения Go на самом деле делают его более подходящим для предприятий и крупных организаций, чем более сложные и мощные языки, такие как Rust.</p>
<h2 id="razlichiia">Различия</h2>
<p>Хотя Rust и Go являются популярными, современными, широко используемыми языками, на самом деле они не являются конкурентами в том смысле, что намеренно нацелены на совершенно разные варианты использования. Подход Go к программированию в целом радикально отличается от подхода Rust, и каждый язык подходит одним людям, а других раздражает. Это абсолютно нормально, и если бы и Rust, и Go выполняли более или менее одинаковые вещи более или менее одинаково, нам действительно не понадобились бы два разных языка.</p>
<p>Итак, можем ли мы понять суть Rust и Go, найдя проблемы, к которым они используют совершенно разные подходы? Давайте разберемся.</p>
<h3 id="vyvoz-musora">Вывоз мусора</h3>
<p>«Убирать мусор или не собирать мусор» - один из тех вопросов, на который нет правильного ответа. Сборка мусора и автоматическое управление памятью в целом позволяют быстро и легко разрабатывать надежные и эффективные программы, а для некоторых людей это очень важно. Но другие говорят, что сборка мусора с ее накладными расходами и остановками мира заставляет программы вести себя непредсказуемо во время выполнения и приводит к недопустимой задержке. Споры продолжаются.</p>
<p>Go - это совсем другой язык по сравнению с Rust. Хотя оба языка можно смутно описать как системные языки или замену C, у них разные цели и приложения, стили языковой разработки и приоритеты. Сборка мусора - действительно серьезное отличие. Наличие GC в Go делает язык намного проще и компактнее, и его легко рассуждать.</p>
<blockquote>
<p>Отсутствие GC в Rust делает его действительно быстрым (особенно если вам нужна гарантированная задержка, а не просто высокая пропускная способность) и включает функции и шаблоны программирования, которые невозможны в Go (или, по крайней мере, без ущерба для производительности). — PingCAP</p>
</blockquote>
<h3 id="blizko-k-metallu">Близко к металлу</h3>
<p>История компьютерного программирования - это история все более сложных абстракций, которые позволяют программисту решать проблемы, не слишком заботясь о том, как на самом деле работает базовая машина. Это упрощает написание программ и, возможно, делает их более переносимыми. Но для многих программ более важны доступ к оборудованию и точный контроль над выполнением программы. Rust нацелен на то, чтобы позволить программистам «приблизиться к металлу» с большим контролем, но Go абстрагирует архитектурные детали, чтобы позволить программистам приблизиться к проблеме.</p>
<blockquote>
<p>Оба языка имеют разную сферу применения. Golang отлично подходит для написания микросервисов и типичных задач DevOps, но это не язык системного программирования. Rust лучше подходит для задач, где важны параллелизм, безопасность и/или производительность; но у него более крутая кривая обучения, чем у Go. — Матиас Эндлер </p>
</blockquote>
<h3 id="dolzhen-li-go-byt-bystree">Должен ли Go быть быстрее</h3>
<p>Многие согласны с тем, что для большинства программ производительность менее важна, чем удобочитаемость. Но когда производительность имеет значение, это действительно имеет значение. Rust делает ряд компромиссов в дизайне для достижения максимально возможной скорости выполнения. В отличие от этого, Go больше заботится о простоте и ради нее готов пожертвовать некоторой производительностью (во время выполнения). Но скорость сборки Go непревзойденная, и это важно для больших кодовых баз.</p>
<p>Rust быстрее Go. В приведенных выше тестах Rust был быстрее, а в некоторых случаях и на порядок быстрее. Но прежде чем вы откажетесь писать все на Rust, примите во внимание, что Go не так уж сильно отстал от него во многих из этих тестов, и он все еще намного быстрее, чем подобные Java, C#, JavaScript, Python и т.д.</p>
<blockquote>
<p>Если вам нужна высочайшая производительность, вы будете впереди всех, выбрав любой из этих двух языков. Если вы создаете веб-сервис, который обрабатывает высокую нагрузку, и хотите, чтобы его можно было масштабировать как по вертикали, так и по горизонтали, любой язык вам идеально подойдет. — Эндрю Лейдер</p>
</blockquote>
<h3 id="pravil-nost">Правильность</h3>
<p>С другой стороны, программа может быть сколь угодно быстрой, если ей не нужно работать должным образом. Большая часть кода не пишется для долгосрочного использования, но часто удивительно, как долго некоторые программы могут оставаться в рабочем состоянии: в некоторых случаях на многие десятилетия. В таких ситуациях стоит потратить немного больше времени на разработку, чтобы убедиться, что программа правильная, надежная и не требует значительного обслуживания в будущем.</p>
<p>Go и Rust нацелены на то, чтобы помочь вам писать правильные программы, но по-разному: Go предоставляет, например, превосходную встроенную среду тестирования, в то время как Rust сосредоточен на устранении ошибок времени выполнения с помощью своей программы проверки заимствований.</p>
<blockquote>
<p>Мое мнение: выберите код, который должен выйти завтра, а Rust - код, который должен работать без изменений в течение следующих пяти лет. — Гжегож Носек</p>
</blockquote>
<p>Хотя и Go, и Rust являются отличным выбором для любого серьезного проекта, рекомендуется как можно лучше узнать о каждом языке и его характеристиках. В конечном счете, не имеет значения, что думают другие: только вы можете решить, что подходит вам и вашей команде.</p>
<blockquote>
<p>Если вы хотите развиваться быстрее, возможно, из-за того, что вам нужно написать много разных сервисов или у вас большая команда разработчиков, то Go - ваш предпочтительный язык. Go дает вам возможность параллелизма как первоклассного гражданина и не допускает небезопасного доступа к памяти (как и Rust), но не заставляет вас управлять всеми мельчайшими деталями. Go быстрый и мощный, но он не утомляет разработчика, вместо этого сосредоточиваясь на простоте и единообразии. Если, с другой стороны, необходимо выжать максимум из производительности, тогда Rust должен быть вашим выбором. — Эндрю Лейдер</p>
</blockquote>
<h2 id="vyvod">Вывод</h2>
<p>Я надеюсь, что эта статья убедила вас в том, что и Rust, и Go заслуживают серьезного внимания. Если это вообще возможно, вы должны стремиться получить хотя бы некоторый уровень опыта в обоих языках, потому что они будут невероятно полезны для вас в любой технической карьере или даже если вы любите программирование в качестве хобби. Если у вас есть время только на то, чтобы хорошо изучить один язык, не принимайте окончательного решения, пока не используете Go и Rust для множества различных программ, больших и малых.</p>
<p>А знание языка программирования - это лишь малая часть того, чтобы быть успешным инженером-программистом. Безусловно, наиболее важными навыками, которые вам понадобятся, являются дизайн, инженерия, архитектура, коммуникация и сотрудничество. Если вы преуспеете в этом, вы станете отличным инженером-программистом независимо от того, какой язык вы выберете. Удачного обучения! </p>
<h3 id="sravnenie-koda-rust-i-go">Сравнение кода Rust и Go</h3>
<p>Есть отличный веб-сайт Programming-idioms.org, на котором есть «шпаргалка», показывающая, как выглядит код Rust и Go для более чем 200 общих задач программирования:</p>
<ul>
<li>
<p>Идиомы Go vs Rust
На GoLab / RustLab 2021 прошла симпатичная панельная дискуссия по теме:</p>
</li>
<li>
<p>Панель Rust vs Go</p>
</li>
</ul>
<h3 id="nachinaia">Начиная</h3>
<p>Если вы хотите научиться программировать на Rust and Go, вот несколько ресурсов, которые могут оказаться вам полезными.</p>
<h4 id="idti">Идти</h4>
<ul>
<li>Установить Go</li>
<li>Учебники Go от Bitfield</li>
<li>Из любви к го</li>
<li>Экскурсия по го</li>
<li>Подавать пример</li>
<li>Игровая площадка Го</li>
<li>Потрясающая игра</li>
</ul>
<h4 id="rust">Rust</h4>
<ul>
<li>Установить Rust</li>
<li>Нежное введение в Rust</li>
<li>Язык программирования Rust</li>
<li>Rust книги</li>
<li>Пример Rust</li>
<li>Игровая площадка Rust</li>
<li>Сто двоичных файлов Rust</li>
</ul>
<h3 id="blagodarnosti">Благодарности</h3>
<p>Как говорится, я недостаточно молод, чтобы знать все, поэтому я очень благодарен ряду выдающихся сусликов и рустообразных, которые нашли время, чтобы просмотреть и исправить эту статью, а также дать несколько действительно полезных советов. Я особенно благодарен Биллу Кеннеди, Гжегожу Носеку, Сэму Роузу, Джеку Мотту, Стиву Клабнику, М. Н. Марку, Оле Нордстром, Леви Лавлоку, Эмилю Пелсу, Себастьяну Лауэрсу, Карлу Лершу и всем, кто внес свой вклад. Читая популярные онлайн-версии, у вас может сложиться впечатление, что сообщества Rust и Go не ладят. По моему опыту, нет ничего более далекого от истины; у нас были очень цивилизованные и плодотворные обсуждения черновика статьи, и это сильно повлияло на конечный продукт. Еще раз спасибо. </p>










<script src="https://giscus.app/client.js"
    data-repo="dudochkin-victor&#x2F;dudochkin-victor.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkzNzgwNTYx"
    data-category="General"
    data-category-id="DIC_kwDOADmv0c4CAhvj"
    data-mapping="pathname"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async>
</script>



        </div>

        
        
    </main>

    
    <footer>
        <small class="subtext">
            <a href="https://angular-rust.github.io">Dudochkin Victor</a> © 2021
        </small>
    </footer>
    
</body>
<script>
    function highlightNav(heading) {
        let pathname = location.pathname;
        document.querySelectorAll(".toc a").forEach((item) => {
            item.classList.remove("active");
        });
        document.querySelector(".toc a[href$='" + pathname + "#" + heading + "']").classList.add("active");
    }

    let currentHeading = "";
    window.onscroll = function () {
        let h = document.querySelectorAll("h1,h2,h3,h4,h5,h6");
        let elementArr = [];

        h.forEach(item => {
            if (item.id !== "") {
                elementArr[item.id] = item.getBoundingClientRect().top;
            }
        });
        elementArr.sort();
        for (let key in elementArr) {
            if (!elementArr.hasOwnProperty(key)) {
                continue;
            }
            if (elementArr[key] > 0 && elementArr[key] < 300) {
                if (currentHeading !== key) {
                    highlightNav(key);
                    currentHeading = key;
                }
                break;
            }
        }
    }
</script>

</html>
