<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Своевременный поток данных: основные концепции | Dudochkin Victor </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="google-site-verification" content="Kepqb6k6uptlwngnHbBVJmqQtwNW8zfHyQBbTXLYAgA" />
    <meta name="yandex-verification" content="8e8bc73c2566b473" />
    <style>
    :root {
        /* Primary theme color */
        /* --primary-color: #121A26; */
        --primary-color: #0f1419;
        /* Primary theme text color */
        /* --primary-text-color: #121A26; */
        --primary-text-color: #0f1419;
        /* Primary theme link color */
        --primary-link-color: #053961;
        /* Secondary color: the background body color */
        --secondary-color: #F0F0F0;
        --secondary-text-color: #1C2834;
        /* Highlight text color of table of content */
        --toc-highlight-text-color: #053961;
    }
</style>
    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-47MMPLLY44"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-47MMPLLY44');
    </script>
    

    
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
    
        ym('87064264', "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/87064264" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    
    
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="/mdl.min.css">
    <link rel="stylesheet" href="https://dudochkin-victor.github.io/style.css">
    
    
</head>

<body>
    
<header class="box-shadow">
    

<a href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;">
    <div class="logo">
        <img src="https://dudochkin-victor.github.io/ferris.png" alt="logo">
        Dudochkin Victor
    </div>
</a>

<nav>
    <!-- 
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;showcases&#x2F;">Showcases</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;changelog&#x2F;">Changelog</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;about&#x2F;">About</a>
     -->

    
        
        <a class="nav-item subtitle-text" href="&#x2F;solana&#x2F;">Solana</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;edgeware&#x2F;">Edgeware</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;blog&#x2F;">Блог</a>
        
        <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;github.com&#x2F;dudochkin-victor">Github</a>
        
    
</nav>

</header>

 
    <main>
        
        
        
        
        
        <div class="toc">
            <div class="toc-sticky">
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/timely-dataflow-core-concepts/#podkhod">Подход</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/timely-dataflow-core-concepts/#primer">Пример</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/timely-dataflow-core-concepts/#osnovnye-treity">Основные трэйты</a>
                </div>
                
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/timely-dataflow-core-concepts/#svoistvo-otmetki-vremeni"><small>- Свойство отметки времени</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/timely-dataflow-core-concepts/#svoistvo-pathsummary"><small>- Свойство PathSummary</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/timely-dataflow-core-concepts/#svoistvo-scope"><small>- Свойство Scope</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/timely-dataflow-core-concepts/#vremia-vypolneniia"><small>- Время выполнения</small></a>
                </div>
                
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/timely-dataflow-core-concepts/#sleduiushchie-shagi">Следующие шаги</a>
                </div>
                
                
            </div>
        </div>
        
        

        <div class="content text">
            
<h1>Своевременный поток данных: основные концепции</h1>

<p><a href="http://www.frankmcsherry.org/dataflow/naiad/2014/12/29/TD_time_summaries.html">Перевод</a> | Автор оригинала: Frank McSherry</p>
<p>Это второй пост в серии о своевременном потоке данных. В первом посте был дан обзор некоторого контекста для своевременного потока данных и предложений по новым направлениям. В этом посте мы начнем подробно рассказывать о некоторых подвижных частях нового иерархического подхода.</p>
<p>Наш план состоит в том, чтобы организовать своевременные графы потоков данных иерархически во вложенные области, каждая из которых может быть реализована другими своевременными графами потоков данных. Это дает несколько преимуществ, в основном из-за того, что уровень абстракции скрывает детали, которые другим частям внешнего графика своевременного потока данных знать не обязательно. С другой стороны, нам нужно будет тщательно продумать границу абстракции, чтобы не терять точность.</p>
<h2 id="podkhod">Подход</h2>
<p>В то время как Naiad сохранил плоское представление графика своевременного потока данных с подсчетами для каждой пары (местоположение, временная метка), указывающей на незавершенную работу, нам нужно будет использовать другой подход. Вместо того, чтобы представлять такие мелкие детали о том, где находится незавершенная работа, всем участникам, мы воспользуемся иерархической структурой, чтобы упростить информацию.</p>
<p>Каждая область будет проецировать незавершенную работу на свои выходы, сообщая для каждого выхода временные метки, в которые могут появиться сообщения. По мере выполнения работы он будет сообщать о ходе выполнения внешнему графику своевременного потока данных в виде изменений в счетчиках для пар (выход, временная метка).</p>
<p>Точно так же незавершенная работа и прогресс, достигнутый в другом месте графика, сначала проецируются на входные данные области, а затем передаются в подграф.</p>
<h2 id="primer">Пример</h2>
<p>В качестве примера мы заимствуем огромную цифру из статьи Naiad.</p>
<p><img src="/imgs/posts/57f47f33_01.png" alt="Мой полезный скриншот" /></p>
<p>В этом примере у нас есть два контекста, или «области видимости», как мы их будем называть: внешняя «потоковая» область видимости и внутренняя область «цикла». В то время как область внутреннего цикла может быстро прогрессировать, вершина D внешней потоковой области должна быть проинформирована только тогда, когда будет достигнут некоторый внешне видимый прогресс. В частности, когда выходные данные области внутреннего цикла больше не будут создавать сообщения с определенной меткой времени.</p>
<p>Фактически, внешней потоковой области не нужно ничего знать об области внутреннего цикла, кроме того, что у нее есть один вход и один выход, а также всякий раз, когда он делает внешне видимый прогресс.</p>
<p>Наш план состоит в том, чтобы просто структурировать механизмы отслеживания прогресса в соответствии с этими принципами, сообщая о прогрессе в восходящем направлении, прогнозируя все нерелевантные детали и объединяя (а часто и отменяя) результаты.</p>
<p>Как правило, есть и другие вещи, о которых внешнему прицелу будет полезно знать, что этот рисунок не особенно хорошо демонстрирует. Если бы во внутренней области было несколько входов и выходов, было бы полезно знать, какие входы связаны с какими выходами. Если бы у внутренней области был экзогенный источник входных данных, ей нужно было бы предупредить внешнюю область, чтобы ожидать этого. Мы разберемся в этих деталях.</p>
<h2 id="osnovnye-treity">Основные трэйты</h2>
<p>В основе нашего подхода к своевременному потоку данных лежат три характеристики: Timestamp, PathSummary и Scope. У каждой области есть свои собственные типы сводки времени и пути, реализующие соответствующие трэйты.</p>
<h3 id="svoistvo-otmetki-vremeni">Свойство отметки времени</h3>
<p>Типаж Timestamp представляет тип, подходящий для использования в качестве отметки времени сообщения. В Naiad эту роль играла последовательность беззнаковых целых чисел. Мы планируем использовать более общие временные метки, но с некоторыми ограничениями, в частности (из кода):</p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">trait </span><span style="color:#59c2ff;">Timestamp</span><span>: PartialOrd+Eq+PartialEq+Copy+Default+Hash+Show+Send+&#39;static { }
</span></code></pre>
<p>Это что-то вроде беспорядка, и, строго говоря, не все ограничения необходимы. Просто полезно.</p>
<p>Наиболее подходящим ограничением является PartialOrd, который предоставляет методы le, lt, ge, gt для сравнения двух элементов одного типа. Типы, реализующие Timestamp, должны быть частично упорядочены.</p>
<h3 id="svoistvo-pathsummary">Свойство PathSummary</h3>
<p>Типаж PathSummary параметризуется типом, реализующим Timestamp. Он указывает, как следует ожидать продвижения метки времени по мере ее перемещения из одного места в другое на графике своевременного потока данных. Он также обеспечивает поддержку для объединения двух сводок (резюмируя конкатенированные пути). </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">trait </span><span style="color:#59c2ff;">PathSummary</span><span>&lt;T&gt; : PartialOrd+Eq+Copy+Clone+Show+Default+&#39;static
</span><span>{
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">results_in</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#f29718;">self</span><span>, </span><span style="color:#f29718;">timestamp</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span>T) </span><span style="color:#bfbab0cc;">-&gt;</span><span> T</span><span style="color:#bfbab0cc;">;       </span><span style="font-style:italic;color:#5c6773;">// advances a timestamp
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">followed_by</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#f29718;">self</span><span>, </span><span style="color:#f29718;">other</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">Self</span><span>) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="color:#ff7733;">Self</span><span style="color:#bfbab0cc;">;    </span><span style="font-style:italic;color:#5c6773;">// composes two summaries
</span><span>}
</span></code></pre>
<p>Сводные данные о путях позволяют нам переводить события в каком-то удаленном месте в локальные последствия события. Если удаленная вершина завершает обработку последнего из своих входов и не производит выходных данных, какая временная метка (или временные метки) должна быть уменьшена локально?</p>
<p>Чтобы суммировать все пути из одного места в другое, мы используем тот факт, что типы, реализующие PathSummary, частично упорядочены, и что нас интересуют самые ранние временные метки, которые могут появиться. Любой набор сводок путей может быть сокращен до тех элементов, которые не строго меньше, чем какой-либо другой элемент набора, что мы упрощаем с помощью структуры <code>Antichain &lt;S&gt;</code>.</p>
<p>Вероятно, что свойство будет обновляться по мере обнаружения дополнительных ограничений. Например, очень вероятно, что results_in должен возвращать типы Option<T> или Iterator<T>, а не отдельные элементы. В противном случае может быть трудно приспособить ограниченные циклы, которые отбрасывают сообщения, когда их временная метка превышает границу цикла. Вероятно, существуют и другие подобные неподдерживаемые шаблоны.</p>
<h3 id="svoistvo-scope">Свойство Scope</h3>
<p>Трэйта Scope - это то, где кусочки начинают сходиться воедино. Область видимости представляет собой элемент на графике своевременного потока данных, видимый из внешнего мира (или его родительской области). Область параметризуется типом временной метки T и типом сводки пути S. Для реализации трэйта тип должен предоставлять несколько методов, которые мы скоро подробно опишем (некоторые методы диагностики опущены). </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">trait </span><span style="color:#59c2ff;">Scope</span><span>&lt;T: Timestamp, S: PathSummary&lt;T&gt;&gt; : &#39;static
</span><span>{
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">inputs</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#f29718;">self</span><span>) </span><span style="color:#bfbab0cc;">-&gt;</span><span> uint</span><span style="color:#bfbab0cc;">;   </span><span style="font-style:italic;color:#5c6773;">// number of inputs
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">outputs</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#f29718;">self</span><span>) </span><span style="color:#bfbab0cc;">-&gt;</span><span> uint</span><span style="color:#bfbab0cc;">;  </span><span style="font-style:italic;color:#5c6773;">// number of outputs
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// get and set summary information as part of set-up.
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">get_internal_summary</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">self</span><span>) </span><span style="color:#bfbab0cc;">-&gt; </span><span>(</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;Antichain&lt;S&gt;&gt;&gt;,
</span><span>                                           </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;(T, </span><span style="color:#ff7733;">i64</span><span>)&gt;&gt;) </span><span style="color:#bfbab0cc;">-&gt;</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">set_external_summary</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">self</span><span>, </span><span style="color:#f29718;">summaries</span><span style="color:#bfbab0cc;">: </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;Antichain&lt;S&gt;&gt;&gt;,
</span><span>                                       </span><span style="color:#f29718;">external</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;(T, </span><span style="color:#ff7733;">i64</span><span>)&gt;&gt;) </span><span style="color:#bfbab0cc;">-&gt;</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// push and pull progress information at run-time.
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">push_external_progress</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">self</span><span>, </span><span style="color:#f29718;">external</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;(T, </span><span style="color:#ff7733;">i64</span><span>)&gt;&gt;) </span><span style="color:#bfbab0cc;">-&gt;</span><span>()</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">pull_internal_progress</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">self</span><span>, </span><span style="color:#f29718;">internal</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;(T, </span><span style="color:#ff7733;">i64</span><span>)&gt;&gt;,
</span><span>                                         </span><span style="color:#f29718;">consumed</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;(T, </span><span style="color:#ff7733;">i64</span><span>)&gt;&gt;,
</span><span>                                         </span><span style="color:#f29718;">produced</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;(T, </span><span style="color:#ff7733;">i64</span><span>)&gt;&gt;) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="color:#ff7733;">bool</span><span style="color:#bfbab0cc;">;
</span><span>}
</span></code></pre>
<p>Это определение звучит сложно, но я надеюсь, что к концу поста причины для каждой из частей станут более ясными.</p>
<h4 id="vkhody-i-vykhody">Входы и выходы</h4>
<p>Каждая область видимости для внешнего мира представляет собой вершину, которая потребляет и производит сообщения с отметкой времени T. Первое, что нужно знать внешнему миру, - это форма области: сколько входов у нее есть и сколько выходов она делает. имеют. Хотя это и не является концептуально глубоким, все дальнейшее общение между осциллографом и внешним миром будет происходить в терминах этих входов и выходов.</p>
<h4 id="initsializatsiia">Инициализация</h4>
<p>Два метода используются как часть инициализации вычислений: область действия суммирует себя с внешним миром, а внешний мир суммирует себя обратно в область действия. Из-за иерархической структуры области сначала суммируются до своей родительской области, которая в конечном итоге получает достаточно информации, чтобы суммировать структуру вокруг области до самой области.</p>
<p>Эти сводки включают как то, что область действия (и внешний мир) способна делать с сообщениями, полученными на их входах, с точки зрения сообщений, созданных на их выходах, так и любые начальные подсчеты сообщений с отметками времени на каждом выходе.</p>
<p>Первый метод - get_internal_summary, который запрашивает у области видимости сводки путей для каждой из пар (вход, выход), а также начальные подсчеты на каждом из выходов для каждой временной метки. </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">get_internal_summary</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">self</span><span>) </span><span style="color:#bfbab0cc;">-&gt; </span><span>(</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;Antichain&lt;S&gt;&gt;&gt;,
</span><span>                                       </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;(T, </span><span style="color:#ff7733;">i64</span><span>)&gt;&gt;) </span><span style="color:#bfbab0cc;">-&gt;</span><span>()</span><span style="color:#bfbab0cc;">;
</span></code></pre>
<p>Результатом является просто пара сводок для каждого входа к каждому выходу и список для каждого выхода приращений к счетчикам для каждой временной метки.</p>
<p>Второй метод - set_internal_summary, который сообщает области видимости сводные данные о пути от каждого из своих выходов обратно к своим входам, а также начальные подсчеты для каждого из своих входов. </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">set_external_summary</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">self</span><span>, </span><span style="color:#f29718;">summaries</span><span style="color:#bfbab0cc;">: </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;Antichain&lt;S&gt;&gt;&gt;,
</span><span>                                   </span><span style="color:#f29718;">external</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;(T, </span><span style="color:#ff7733;">i64</span><span>)&gt;&gt;) </span><span style="color:#bfbab0cc;">-&gt;</span><span>()</span><span style="color:#bfbab0cc;">;
</span></code></pre>
<p>Два аргумента являются аналогами возвращенных значений выше: сводные данные о путях от каждого выхода области к каждому из входов области и начальные подсчеты на каждом из входов области.</p>
<h3 id="vremia-vypolneniia">Время выполнения</h3>
<p>Как только вычисление началось, внешний мир взаимодействует с осциллографом двумя способами: он уведомляет объем прогресса, достигнутого во внешнем мире, и запрашивает информацию о прогрессе, достигнутом в самой области. Это методы push_external_progress и pull_internal_progress.</p>
<p>Первый из этих двух методов относительно прост: он передает в область видимости список обновлений счетчиков временных меток для каждого из своих входов. Эти обновления сообщают о прогрессе во внешнем мире, прогнозируемом вплоть до входов осциллографа. </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">push_external_progress</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">self</span><span>, </span><span style="color:#f29718;">external</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;(T, </span><span style="color:#ff7733;">i64</span><span>)&gt;&gt;) </span><span style="color:#bfbab0cc;">-&gt;</span><span>()</span><span style="color:#bfbab0cc;">;
</span></code></pre>
<p>Метод ничего не возвращает, что отражает наше желание, чтобы это было асинхронным взаимодействием: уведомление не связано с ответом, оно просто отправляется в область видимости из внешнего мира с надеждой, что прогресс будет достигнут в будущем.</p>
<p>Второй способ немного сложнее, по крайней мере, сигнатурно. Его роль заключается в получении информации из области видимости о достигнутом прогрессе, чтобы система в целом могла развиваться. </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">pull_internal_progress</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="color:#f29718;">self</span><span>, </span><span style="color:#f29718;">internal</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;(T, </span><span style="color:#ff7733;">i64</span><span>)&gt;&gt;,
</span><span>                                     </span><span style="color:#f29718;">consumed</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;(T, </span><span style="color:#ff7733;">i64</span><span>)&gt;&gt;,
</span><span>                                     </span><span style="color:#f29718;">produced</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;(T, </span><span style="color:#ff7733;">i64</span><span>)&gt;&gt;) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="color:#ff7733;">bool</span><span style="color:#bfbab0cc;">;
</span></code></pre>
<p>Аргументы - это векторы, предназначенные для заполнения, указывающие (соответственно) изменения в любой внутренней работе, проецируемой на выходы области, количество сообщений, потребляемых на каждом из входов области, и количество сообщений, созданных на каждом из выходов области. Метод возвращает логическое значение, указывающее, есть ли незарегистрированная работа, которая может не привести к выходным сообщениям, которые должны предотвратить завершение вычислений (например, вершины с побочными эффектами, но без выходных данных).</p>
<p>Этот метод собирает три типа обновлений вместе, потому что для корректности важно, чтобы два типа обновлений происходили вместе:</p>
<ul>
<li>Использование входящего сообщения приводит к увеличению внутренней работы (потребление -&gt; внутренняя).</li>
<li>Создание выходного сообщения, что приводит к меньшему количеству внутренней работы (внутренняя -&gt; производство).</li>
</ul>
<p>Если любой из этих двух разделится, возможно, внешний мир может иметь неполное (и неправильное) представление о состоянии области видимости. Например, если область действия подтверждает получение входного сообщения, но не указывает на новую внутреннюю работу, внешняя область может разумно предполагать, что ее нет, и сообщать другим неверную информацию о ходе выполнения. Точно так же, если внутренняя работа прекращается, создавая выходное сообщение, нет никаких оснований полагать, что внешний мир будет знать о сообщении своевременно, если только сам объем не сообщил об этом.</p>
<p>Хотя мы могли бы разбить вышеперечисленное на два метода pull_internal, существует хорошая симметрия в наличии одного метода для каждого направления информационного потока. Более того, получение из области видимости только части информации о ходе выполнения пока не дает никаких преимуществ. Область действия может сообщать то, что она хочет сообщить.</p>
<h2 id="sleduiushchie-shagi">Следующие шаги</h2>
<p>Мы описали существующие интерфейсы для нашей иерархической реализации своевременного потока данных. Еще многое предстоит сказать о том, как реализовать области видимости, особенно об общей логике для области действия, которая объединяет связанную коллекцию других областей. Мы поговорим об этом дальше и почти наверняка затронем детали, которые все еще обсуждаются. </p>










<script src="https://giscus.app/client.js"
    data-repo="dudochkin-victor&#x2F;dudochkin-victor.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkzNzgwNTYx"
    data-category="General"
    data-category-id="DIC_kwDOADmv0c4CAhvj"
    data-mapping="pathname"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async>
</script>



        </div>

        
        
    </main>

    
    <footer>
        <small class="subtext">
            <a href="https://angular-rust.github.io">Dudochkin Victor</a> © 2021
        </small>
    </footer>
    
</body>
<script>
    function highlightNav(heading) {
        let pathname = location.pathname;
        document.querySelectorAll(".toc a").forEach((item) => {
            item.classList.remove("active");
        });
        document.querySelector(".toc a[href$='" + pathname + "#" + heading + "']").classList.add("active");
    }

    let currentHeading = "";
    window.onscroll = function () {
        let h = document.querySelectorAll("h1,h2,h3,h4,h5,h6");
        let elementArr = [];

        h.forEach(item => {
            if (item.id !== "") {
                elementArr[item.id] = item.getBoundingClientRect().top;
            }
        });
        elementArr.sort();
        for (let key in elementArr) {
            if (!elementArr.hasOwnProperty(key)) {
                continue;
            }
            if (elementArr[key] > 0 && elementArr[key] < 300) {
                if (currentHeading !== key) {
                    highlightNav(key);
                    currentHeading = key;
                }
                break;
            }
        }
    }
</script>

</html>
