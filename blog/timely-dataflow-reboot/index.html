<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Своевременный поток данных: перезагрузка | Dudochkin Victor </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="google-site-verification" content="Kepqb6k6uptlwngnHbBVJmqQtwNW8zfHyQBbTXLYAgA" />
    <meta name="yandex-verification" content="8e8bc73c2566b473" />
    <style>
    :root {
        /* Primary theme color */
        /* --primary-color: #121A26; */
        --primary-color: #0f1419;
        /* Primary theme text color */
        /* --primary-text-color: #121A26; */
        --primary-text-color: #0f1419;
        /* Primary theme link color */
        --primary-link-color: #053961;
        /* Secondary color: the background body color */
        --secondary-color: #F0F0F0;
        --secondary-text-color: #1C2834;
        /* Highlight text color of table of content */
        --toc-highlight-text-color: #053961;
    }
</style>
    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-47MMPLLY44"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-47MMPLLY44');
    </script>
    

    
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
    
        ym('87064264', "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/87064264" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    
    
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="/mdl.min.css">
    <link rel="stylesheet" href="https://dudochkin-victor.github.io/style.css">
    
    
</head>

<body>
    
<header class="box-shadow">
    

<a href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;">
    <div class="logo">
        <img src="https://dudochkin-victor.github.io/ferris.png" alt="logo">
        Dudochkin Victor
    </div>
</a>

<nav>
    <!-- 
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;showcases&#x2F;">Showcases</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;changelog&#x2F;">Changelog</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;about&#x2F;">About</a>
     -->

    
        
        <a class="nav-item subtitle-text" href="&#x2F;solana&#x2F;">Solana</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;edgeware&#x2F;">Edgeware</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;blog&#x2F;">Блог</a>
        
        <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;github.com&#x2F;dudochkin-victor">Github</a>
        
    
</nav>

</header>

 
    <main>
        
        
        
        
        
        <div class="toc">
            <div class="toc-sticky">
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/timely-dataflow-reboot/#naiad-i-svoevremennyi-potok-dannykh">Naiad и своевременный поток данных</a>
                </div>
                
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/timely-dataflow-reboot/#otslezhivanie-progressa-v-naiad"><small>- Отслеживание прогресса в Naiad</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/timely-dataflow-reboot/#ogranicheniia-podkhoda-naiady"><small>- Ограничения подхода Наяды</small></a>
                </div>
                
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/timely-dataflow-reboot/#pereosmyslenie-svoevremennogo-potoka-dannykh">Переосмысление своевременного потока данных</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/timely-dataflow-reboot/#predstoiashchie-publikatsii">Предстоящие публикации</a>
                </div>
                
                
            </div>
        </div>
        
        

        <div class="content text">
            
<h1>Своевременный поток данных: перезагрузка</h1>

<p><a href="http://www.frankmcsherry.org/dataflow/naiad/2014/12/27/Timely-Dataflow.html">Перевод</a> | Автор оригинала: Frank McSherry</p>
<p>Поток данных - популярная основа для многих масштабируемых вычислений, потому что структура вычислений фиксируется до выполнения, и единственная ответственность рабочих - реагировать на входящие данные. Основная ответственность хост-системы - доставить данные соответствующим работникам, и это вполне выполнимая задача.</p>
<p>Многие практические системы потоков данных нуждаются в дополнительных функциях, помимо простой доставки данных. Самая неотложная потребность - это возможность сообщить работнику, что он получил все ожидаемые данные. Это позволяет исполнителю завершить вычисления, выдать исходящие сообщения и очистить постоянное состояние. При более высокой степени детализации системы потоковых данных нуждаются в возможности сообщать работнику, когда они получили все данные для логического подмножества их ввода, например, о конце логического пакета, для которого требуется вывод.</p>
<h2 id="naiad-i-svoevremennyi-potok-dannykh">Naiad и своевременный поток данных</h2>
<p>Своевременный поток данных - это название, которое мы использовали для описания модели потока данных Naiad. Модель включает в себя ориентированный (возможно, циклический) граф, по краям которого проходят сообщения (данные), и частично упорядоченный набор временных меток, украшающих каждое сообщение. Каждое сообщение условно существует в определенном месте на графике в логический момент времени, пару которых мы назвали отметкой точки. Как указано выше, эти отметки могут не иметь ничего общего с физическим временем; они часто отражали прогресс в потоке (указывающий эпоху входных данных) или прохождение цикла (указывающий итерацию).</p>
<p>Наложение нескольких структурных ограничений (исключенных) на граф потока данных обеспечивает частичный порядок в парах (местоположение, временная метка). Это означает, что для любого набора точечных меток сообщения в одном могут привести к созданию сообщений в другом, но между ними не может быть цикла. Хотя отсутствие полного порядка означает, что мы не можем назвать «самую раннюю» точечную метку в нашем наборе, мы, тем не менее, можем установить набор точечных меток, которые больше никогда не будут видны после того, как мы доставим соответствующие сообщения.</p>
<h3 id="otslezhivanie-progressa-v-naiad">Отслеживание прогресса в Naiad</h3>
<p>Задача Naiad - поддерживать понимание того, какие отметки точек все еще используются, в любое время, чтобы каждый из ее сотрудников знал, когда они будут уверены, что никогда больше не увидят данную отметку. Здесь есть несколько подходов, я рекомендую документ &quot;Обработка вне очереди&quot; в качестве хорошей отправной точки. Однако подход Наяды можно довольно легко резюмировать.</p>
<p>Отслеживание прогресса в Naiad - это, по сути, распределенный подсчет ссылок. Каждый рабочий ведет счет для каждой точечной метки количества сообщений, которые, по его мнению, все еще активны (счетчики ссылок). Когда рабочий обрабатывает сообщение с отметкой точки, он может создавать выходные сообщения с другими отметками точки; он передает каждому рабочему приращение для каждой выходной точки и декремент для входной точки.</p>
<p>Naiad содержит несколько оптимизаций этого подхода, в основном определяющих моменты, когда работник может безопасно накапливать обновления счетчика ссылок, не рискуя при этом останавливать систему. В основном это включает в себя замечание, что ему еще нужно поработать для декремента, который он может отправить, и ему нужно просто подождать, пока он не завершит работу, поскольку частичная информация не позволит другим добиться прогресса.</p>
<h3 id="ogranicheniia-podkhoda-naiady">Ограничения подхода Наяды</h3>
<p>Граф своевременного потока данных, которым управляет Naiad, имеет некоторую структуру, и Naiad представляет его в своей логике отслеживания прогресса просто в виде ориентированного графа. Хотя вершины могут иметь разные типы отметок времени, они ограничены кортежами целых чисел разной степени арности. Это связано с тем, что Naiad необходимо объявить общий тип для точечных штампов, чтобы их можно было сравнивать среди прочего. Использование полной универсальности своевременного потока данных, выбор различных частичных порядков для разных подграфов не представлялось возможным в Naiad с точки зрения типобезопасности.</p>
<h2 id="pereosmyslenie-svoevremennogo-potoka-dannykh">Переосмысление своевременного потока данных</h2>
<p>Мне дали время подумать о том, как структурировать отслеживание прогресса в своевременном потоке данных, и я придумал что-то новое и интересное. Подход моделирует своевременные графы потоков данных иерархически, где подграф представляет собой вершину в виде вершины графического уровня над ним, скрывая детали реализации и представляя минимальный (подробный в ближайшее время) интерфейс координации.</p>
<p>Он еще не полностью построен, поэтому трудно сказать, будет ли он лучше, но у него есть несколько привлекательных преимуществ по сравнению с подходом Naiad: </p>
<ul>
<li>
<p>Подграфы могут дополнять свои временные метки любым частично упорядоченным набором.</p>
<p>Хотя целые числа по-прежнему популярны, это позволяет использовать такие типы, как DateTime в корневой области видимости, приоритеты (uint, uint) (обманутые в Naiad) и Vec<Stack> для рекурсивных вычислений. Это также приводит к тому, что не требуется динамически выделяемая память для основных типов временных меток.</p>
</li>
<li>
<p>Подграфы могут легко координироваться между подмножествами работников.</p>
<p>Это обеспечивает более тесную координацию, когда это необходимо, например, когда работники машины хотят агрегировать значения перед их передачей. Это также позволяет значительно упростить реализацию «олицетворения», часто комментируемой функции Naiad, которая ускоряет координацию, когда известно, что некоторые ребра не будут обмениваться данными.</p>
</li>
<li>
<p>Подграфы могут быть реализованы на других языках или в других средах выполнения.</p>
<p>Наш выбор C# и .NET не был особенно популярен, но в то же время использование Java во многом противоречит созданию эффективных систем. Естественным компромиссом является создание логики координации и других необходимых сервисов на языке, который пользователь не ожидает знать, и позволяющий им писать свои приложения в выбранной среде.</p>
</li>
<li>
<p>Подграфы могут координироваться без участия плоскости данных.</p>
<p>Дизайн Naiad в значительной степени достиг этого, но он был слишком удобен в реализации, чтобы связывать передачу данных с обновлением хода выполнения. Эта конструкция требует, чтобы они изначально были отдельными, хотя, очевидно, можно построить удобные слои. Эта функция предназначена для поддержки передачи данных через другие носители, включая распределенные файловые системы и общие очереди.</p>
</li>
</ul>
<h2 id="predstoiashchie-publikatsii">Предстоящие публикации</h2>
<p>Моя цель в этом проекте - увидеть, насколько можно дразнить идею системы больших данных как операционной системы; каков минимальный набор сервисов и функций, которые должна обеспечивать платформа для масштабируемых вычислений, не ограничивая иным образом выполняемые программы.</p>
<p>Я планирую размещать сообщения по нескольким связанным темам в течение следующих нескольких недель, по мере того, как будет достигнут прогресс. В настоящее время существует прототип, работающий с новым подходом, выполняющий разные действия, начиная с обыденного параллельного использования данных(), и заканчивая новыми и интересными подграфами, поддерживаемыми внешними процессами, подключенными к координатору только с помощью каналов unix (хорошо, я признаю it; внешние процессы тоже находятся в Rust). Он обменивается данными по потокам, но еще не по сетевым соединениям, и есть некоторые инструменты, которые делают его более приятным в использовании. </p>










<script src="https://giscus.app/client.js"
    data-repo="dudochkin-victor&#x2F;dudochkin-victor.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkzNzgwNTYx"
    data-category="General"
    data-category-id="DIC_kwDOADmv0c4CAhvj"
    data-mapping="pathname"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async>
</script>



        </div>

        
        
    </main>

    
    <footer>
        <small class="subtext">
            <a href="https://angular-rust.github.io">Dudochkin Victor</a> © 2021
        </small>
    </footer>
    
</body>
<script>
    function highlightNav(heading) {
        let pathname = location.pathname;
        document.querySelectorAll(".toc a").forEach((item) => {
            item.classList.remove("active");
        });
        document.querySelector(".toc a[href$='" + pathname + "#" + heading + "']").classList.add("active");
    }

    let currentHeading = "";
    window.onscroll = function () {
        let h = document.querySelectorAll("h1,h2,h3,h4,h5,h6");
        let elementArr = [];

        h.forEach(item => {
            if (item.id !== "") {
                elementArr[item.id] = item.getBoundingClientRect().top;
            }
        });
        elementArr.sort();
        for (let key in elementArr) {
            if (!elementArr.hasOwnProperty(key)) {
                continue;
            }
            if (elementArr[key] > 0 && elementArr[key] < 300) {
                if (currentHeading !== key) {
                    highlightNav(key);
                    currentHeading = key;
                }
                break;
            }
        }
    }
</script>

</html>
