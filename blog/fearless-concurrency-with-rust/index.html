<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Бесстрашный параллелизм с Rust | Dudochkin Victor </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="google-site-verification" content="Kepqb6k6uptlwngnHbBVJmqQtwNW8zfHyQBbTXLYAgA" />
    <meta name="yandex-verification" content="8e8bc73c2566b473" />
    <style>
    :root {
        /* Primary theme color */
        /* --primary-color: #121A26; */
        --primary-color: #0f1419;
        /* Primary theme text color */
        /* --primary-text-color: #121A26; */
        --primary-text-color: #0f1419;
        /* Primary theme link color */
        --primary-link-color: #053961;
        /* Secondary color: the background body color */
        --secondary-color: #F0F0F0;
        --secondary-text-color: #1C2834;
        /* Highlight text color of table of content */
        --toc-highlight-text-color: #053961;
    }
</style>
    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-47MMPLLY44"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-47MMPLLY44');
    </script>
    

    
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
    
        ym('87064264', "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/87064264" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    
    
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="/mdl.min.css">
    <link rel="stylesheet" href="https://dudochkin-victor.github.io/style.css">
    
    
</head>

<body>
    
<header class="box-shadow">
    

<a href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;">
    <div class="logo">
        <img src="https://dudochkin-victor.github.io/ferris.png" alt="logo">
        Dudochkin Victor
    </div>
</a>

<nav>
    <!-- 
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;showcases&#x2F;">Showcases</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;changelog&#x2F;">Changelog</a>
    
    <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;dudochkin-victor.github.io&#x2F;about&#x2F;">About</a>
     -->

    
        
        <a class="nav-item subtitle-text" href="&#x2F;solana&#x2F;">Solana</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;edgeware&#x2F;">Edgeware</a>
        
        <a class="nav-item subtitle-text" href="&#x2F;blog&#x2F;">Блог</a>
        
        <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;github.com&#x2F;dudochkin-victor">Github</a>
        
    
</nav>

</header>

 
    <main>
        
        
        
        
        
        <div class="toc">
            <div class="toc-sticky">
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/fearless-concurrency-with-rust/#predystoriia-vladenie">Предыстория: владение</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/fearless-concurrency-with-rust/#predystoriia-zaimstvovanie">Предыстория: заимствование</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/fearless-concurrency-with-rust/#peredacha-soobshchenii">Передача сообщений</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/fearless-concurrency-with-rust/#zamki">Замки</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/fearless-concurrency-with-rust/#bezopasnost-potokov-i-otpravit">Безопасность потоков и «Отправить»</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/fearless-concurrency-with-rust/#sovmestnoe-ispol-zovanie-steka-scoped">Совместное использование стека: &quot;scoped&quot;</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/fearless-concurrency-with-rust/#gonki-za-dannye">Гонки за данные</a>
                </div>
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://dudochkin-victor.github.io/blog/fearless-concurrency-with-rust/#budushchee">Будущее</a>
                </div>
                
                
            </div>
        </div>
        
        

        <div class="content text">
            
<h1>Бесстрашный параллелизм с Rust</h1>

<p><a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Перевод</a> | Автор оригинала: Aaron Turon</p>
<p>Проект Rust был инициирован для решения двух сложных проблем:</p>
<ul>
<li>Как вы занимаетесь безопасным системным программированием?</li>
<li>Как сделать параллелизм безболезненным?</li>
</ul>
<p>Первоначально эти проблемы казались ортогональными, но, к нашему удивлению, решение оказалось идентичным: те же инструменты, которые делают Rust безопасным, также помогают вам напрямую бороться с параллелизмом.</p>
<p>Ошибки безопасности памяти и ошибки параллелизма часто сводятся к тому, что код обращается к данным, когда этого не следует. Секретное оружие Rust - владение, дисциплина управления доступом, которой стараются следовать системные программисты, но компилятор Rust проверяет ее статически.</p>
<p>Для безопасности памяти это означает, что вы можете программировать без сборщика мусора и не опасаясь ошибок сегментации, потому что Rust отловит ваши ошибки.</p>
<p>Для параллелизма это означает, что вы можете выбирать из множества парадигм (передача сообщений, общее состояние, без блокировки, чисто функциональный), и Rust поможет вам избежать распространенных ошибок.</p>
<p>Вот пример параллелизма в Rust:</p>
<ul>
<li>
<p>Канал передает право собственности на сообщения, отправленные по нему, поэтому вы можете отправлять указатель из одного потока в другой, не опасаясь, что потоки позже будут пытаться получить доступ через этот указатель. Каналы Rust обеспечивают изоляцию потоков.</p>
</li>
<li>
<p>Блокировка знает, какие данные она защищает, и Rust гарантирует, что доступ к данным возможен только тогда, когда блокировка удерживается. Состояние никогда не делится случайно. &quot;Блокировать данные, а не код&quot; принудительно в Rust.</p>
</li>
<li>
<p>Каждый тип данных знает, можно ли безопасно пересылать его между несколькими потоками или получать к ним доступ, и Rust обеспечивает такое безопасное использование; нет никаких гонок данных, даже для структур данных без блокировок. Безопасность потоков - это не просто документация; это закон.</p>
</li>
<li>
<p>Вы даже можете обмениваться кадрами стека между потоками, и Rust будет статически гарантировать, что кадры остаются активными, пока другие потоки их используют. Даже самые смелые формы совместного использования гарантированно безопасны в Rust.</p>
</li>
</ul>
<p>Все эти преимущества проистекают из модели владения Rust, и фактически блокировки, каналы, структуры данных без блокировок и так далее определяются в библиотеках, а не в основном языке. Это означает, что подход Rust к параллелизму является открытым: новые библиотеки могут охватывать новые парадигмы и отлавливать новые ошибки, просто добавляя API, которые используют функции владения Rust.</p>
<p>Цель этой публикации - дать вам некоторое представление о том, как это делается. </p>
<h2 id="predystoriia-vladenie">Предыстория: владение</h2>
<pre style="background-color:#0f1419;color:#bfbab0;"><code><span> Мы начнем с обзора систем владения и заимствования Rust. Если вы уже знакомы с ними, вы можете пропустить два «фоновых» раздела и сразу перейти к параллелизму. Если вы хотите более глубокого знакомства, я не могу рекомендовать пост Иегуды Каца достаточно высоко. И в книге Rust есть все подробности.
</span></code></pre>
<p>В Rust каждое значение имеет «область действия», и передача или возврат значения означает передачу владения («перемещение» его) в новую область. Значения, которые все еще принадлежат, когда область действия заканчивается, автоматически уничтожаются в этой точке.</p>
<p>Давайте посмотрим на несколько простых примеров. Предположим, мы создаем вектор и помещаем в него какие-то элементы: </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">make_vec</span><span>() {
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> vec </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">Vec</span><span style="color:#f29668;">::</span><span>new()</span><span style="color:#bfbab0cc;">; </span><span style="font-style:italic;color:#5c6773;">// owned by make_vec&#39;s scope
</span><span>    vec</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(</span><span style="color:#f29718;">0</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>    vec</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(</span><span style="color:#f29718;">1</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// scope ends, `vec` is destroyed
</span><span>}
</span></code></pre>
<p>Область, создающая ценность, также изначально владеет ею. В этом случае тело make_vec является областью владения для vec. Владелец может делать с vec все, что угодно, в том числе изменять его путем нажатия. В конце области vec по-прежнему принадлежит, поэтому он автоматически освобождается.</p>
<p>Все становится интереснее, если вектор возвращается или передается: </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">make_vec</span><span>() </span><span style="color:#bfbab0cc;">-&gt; </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="color:#ff7733;">i32</span><span>&gt; {
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> vec </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">Vec</span><span style="color:#f29668;">::</span><span>new()</span><span style="color:#bfbab0cc;">;
</span><span>    vec</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(</span><span style="color:#f29718;">0</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>    vec</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(</span><span style="color:#f29718;">1</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>    vec </span><span style="font-style:italic;color:#5c6773;">// transfer ownership to the caller
</span><span>}
</span><span>
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">print_vec</span><span>(</span><span style="color:#f29718;">vec</span><span style="color:#bfbab0cc;">: </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="color:#ff7733;">i32</span><span>&gt;) {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// the `vec` parameter is part of this scope, so it&#39;s owned by `print_vec`
</span><span>
</span><span>    </span><span style="color:#ff7733;">for</span><span> i </span><span style="color:#f29668;">in</span><span> vec</span><span style="color:#f29668;">.</span><span style="color:#f07178;">iter</span><span>() {
</span><span>        </span><span style="color:#f07178;">println!</span><span>(</span><span style="color:#c2d94c;">&quot;</span><span style="color:#f29718;">{}</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">,</span><span> i)
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// now, `vec` is deallocated
</span><span>}
</span><span>
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">use_vec</span><span>() {
</span><span>    </span><span style="color:#ff7733;">let</span><span> vec </span><span style="color:#f29668;">= </span><span style="color:#f07178;">make_vec</span><span>()</span><span style="color:#bfbab0cc;">; </span><span style="font-style:italic;color:#5c6773;">// take ownership of the vector
</span><span>    </span><span style="color:#f07178;">print_vec</span><span>(vec)</span><span style="color:#bfbab0cc;">;       </span><span style="font-style:italic;color:#5c6773;">// pass ownership to `print_vec`
</span><span>}
</span></code></pre>
<p>Теперь, непосредственно перед тем, как закончится область видимости make_vec, vec удаляется путем его возврата; он не разрушен. Вызывающий объект, такой как use_vec, затем получает право владения вектором.</p>
<p>С другой стороны, функция print_vec принимает параметр vec, и право собственности на вектор передается ей вызывающей стороной. Поскольку print_vec больше не передает право собственности, в конце своей области вектор уничтожается.</p>
<p>После передачи права собственности ценность больше не может быть использована. Например, рассмотрим этот вариант use_vec: </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">use_vec</span><span>() {
</span><span>    </span><span style="color:#ff7733;">let</span><span> vec </span><span style="color:#f29668;">= </span><span style="color:#f07178;">make_vec</span><span>()</span><span style="color:#bfbab0cc;">;  </span><span style="font-style:italic;color:#5c6773;">// take ownership of the vector
</span><span>    </span><span style="color:#f07178;">print_vec</span><span>(vec)</span><span style="color:#bfbab0cc;">;        </span><span style="font-style:italic;color:#5c6773;">// pass ownership to `print_vec`
</span><span>
</span><span>    </span><span style="color:#ff7733;">for</span><span> i </span><span style="color:#f29668;">in</span><span> vec</span><span style="color:#f29668;">.</span><span style="color:#f07178;">iter</span><span>() {  </span><span style="font-style:italic;color:#5c6773;">// continue using `vec`
</span><span>        </span><span style="color:#f07178;">println!</span><span>(</span><span style="color:#c2d94c;">&quot;</span><span style="color:#f29718;">{}</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">,</span><span> i </span><span style="color:#f29668;">* </span><span style="color:#f29718;">2</span><span>)
</span><span>    }
</span><span>}
</span></code></pre>
<p>Если вы скармливаете эту версию компилятору, вы получите сообщение об ошибке: </p>
<pre style="background-color:#0f1419;color:#bfbab0;"><code><span>error: use of moved value: `vec`
</span><span>
</span><span>for i in vec.iter() {
</span><span>         ^~~
</span></code></pre>
<p>Компилятор сообщает, что vec больше не доступен; право собственности было передано в другое место. И это очень хорошо, потому что на этом этапе вектор уже освобожден!</p>
<p>Катастрофа предотвращена.</p>
<h2 id="predystoriia-zaimstvovanie">Предыстория: заимствование</h2>
<p>История до сих пор не совсем удовлетворительна, потому что наша цель print_vec не уничтожать данный вектор. На самом деле мы хотим предоставить print_vec временный доступ к вектору, а затем продолжить его использование.</p>
<p>Здесь на помощь приходит заимствование. Если у вас есть доступ к значению в Rust, вы можете предоставить этот доступ вызываемым функциям. Rust проверит, что эти договоры аренды не переживут взятый в аренду объект.</p>
<p>Чтобы заимствовать значение, вы делаете ссылку на него (своего рода указатель) с помощью оператора &amp;: </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">print_vec</span><span>(</span><span style="color:#f29718;">vec</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="color:#ff7733;">i32</span><span>&gt;) {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// the `vec` parameter is borrowed for this scope
</span><span>
</span><span>    </span><span style="color:#ff7733;">for</span><span> i </span><span style="color:#f29668;">in</span><span> vec</span><span style="color:#f29668;">.</span><span style="color:#f07178;">iter</span><span>() {
</span><span>        </span><span style="color:#f07178;">println!</span><span>(</span><span style="color:#c2d94c;">&quot;</span><span style="color:#f29718;">{}</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">,</span><span> i)
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// now, the borrow ends
</span><span>}
</span><span>
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">use_vec</span><span>() {
</span><span>    </span><span style="color:#ff7733;">let</span><span> vec </span><span style="color:#f29668;">= </span><span style="color:#f07178;">make_vec</span><span>()</span><span style="color:#bfbab0cc;">;  </span><span style="font-style:italic;color:#5c6773;">// take ownership of the vector
</span><span>    </span><span style="color:#f07178;">print_vec</span><span>(</span><span style="color:#f29668;">&amp;</span><span>vec)</span><span style="color:#bfbab0cc;">;       </span><span style="font-style:italic;color:#5c6773;">// lend access to `print_vec`
</span><span>    </span><span style="color:#ff7733;">for</span><span> i </span><span style="color:#f29668;">in</span><span> vec</span><span style="color:#f29668;">.</span><span style="color:#f07178;">iter</span><span>() {  </span><span style="font-style:italic;color:#5c6773;">// continue using `vec`
</span><span>        </span><span style="color:#f07178;">println!</span><span>(</span><span style="color:#c2d94c;">&quot;</span><span style="color:#f29718;">{}</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">,</span><span> i </span><span style="color:#f29668;">* </span><span style="color:#f29718;">2</span><span>)
</span><span>    }
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// vec is destroyed here
</span><span>}
</span></code></pre>
<p>Теперь print_vec берет ссылку на вектор, а use_vec одалживает вектор, написав &amp;vec. Поскольку заимствования являются временными, use_vec сохраняет право собственности на вектор; он может продолжать использовать его после возврата из вызова print_vec (и истечения срока его аренды vec).</p>
<p>Каждая ссылка действительна для ограниченной области, которую компилятор определит автоматически. Ссылки бывают двух видов:</p>
<ul>
<li>
<p>Неизменяемые ссылки &amp;T, которые позволяют делиться, но не изменяют. Одновременно может быть несколько ссылок &amp;T на одно и то же значение, но значение нельзя изменить, пока эти ссылки активны.</p>
</li>
<li>
<p>Изменяемые ссылки и mut T, которые разрешают мутации, но не делятся. Если есть ссылка &amp;mut T на значение, в это время не может быть других активных ссылок, но значение может быть изменено.</p>
</li>
</ul>
<p>Rust проверяет эти правила во время компиляции; заимствование не требует дополнительных затрат времени выполнения.</p>
<p>Почему есть два типа ссылок? Рассмотрим такую функцию, как: </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">push_all</span><span>(</span><span style="color:#f29718;">from</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="color:#ff7733;">i32</span><span>&gt;, </span><span style="color:#f29718;">to</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="color:#ff7733;">i32</span><span>&gt;) {
</span><span>    </span><span style="color:#ff7733;">for</span><span> i </span><span style="color:#f29668;">in</span><span> from</span><span style="color:#f29668;">.</span><span style="color:#f07178;">iter</span><span>() {
</span><span>        to</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(</span><span style="color:#f29668;">*</span><span>i)</span><span style="color:#bfbab0cc;">;
</span><span>    }
</span><span>}
</span></code></pre>
<p>Эта функция выполняет итерацию по каждому элементу одного вектора, подталкивая его к другому. Итератор сохраняет указатель на вектор в текущей и конечной позициях, шагая друг к другу.</p>
<p>Что, если бы мы вызвали эту функцию с одним и тем же вектором для обоих аргументов? </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#f07178;">push_all</span><span>(</span><span style="color:#f29668;">&amp;</span><span>vec</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> vec)
</span></code></pre>
<p>Это будет катастрофой! По мере того как мы помещаем элементы в вектор, время от времени ему потребуется изменить размер, выделить новый кусок памяти и скопировать в него свои элементы. У итератора останется висящий указатель на старую память, что приведет к небезопасности памяти (с сопутствующими ошибками сегментирования или хуже).</p>
<p>К счастью, Rust гарантирует, что всякий раз, когда изменяемое заимствование является активным, никакие другие заимствования объекта не будут активными, и будет выдано сообщение: </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span>error</span><span style="color:#bfbab0cc;">:</span><span> cannot borrow `vec` </span><span style="color:#f29668;">as</span><span> mutable because it is also borrowed </span><span style="color:#f29668;">as</span><span> immutable
</span><span style="color:#f07178;">push_all</span><span>(</span><span style="color:#f29668;">&amp;</span><span>vec</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> vec)</span><span style="color:#bfbab0cc;">;
</span><span>                    </span><span style="color:#f29668;">^~~
</span></code></pre>
<p>Катастрофа предотвращена.</p>
<h2 id="peredacha-soobshchenii">Передача сообщений</h2>
<p>Теперь, когда мы рассмотрели базовую историю владения в Rust, давайте посмотрим, что это значит для параллелизма.</p>
<p>Параллельное программирование имеет множество стилей, но особенно простым является передача сообщений, когда потоки или субъекты общаются, отправляя друг другу сообщения. Сторонники стиля подчеркивают, что он связывает воедино обмен и общение:</p>
<pre style="background-color:#0f1419;color:#bfbab0;"><code><span> Не общайтесь, разделяя память; вместо этого поделитесь памятью, общаясь.
</span><span>
</span><span> - Эффективный Go
</span></code></pre>
<p>Владение Rust позволяет легко превратить этот совет в правило, проверяемое компилятором. Рассмотрим следующий API каналов (каналы в стандартной библиотеке Rust немного отличаются): </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">send</span><span>&lt;T</span><span style="color:#bfbab0cc;">: </span><span style="font-style:italic;color:#39bae6;">Send</span><span>&gt;(</span><span style="color:#f29718;">chan</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span>Channel&lt;T&gt;, </span><span style="color:#f29718;">t</span><span style="color:#bfbab0cc;">:</span><span> T)</span><span style="color:#bfbab0cc;">;
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">recv</span><span>&lt;T</span><span style="color:#bfbab0cc;">: </span><span style="font-style:italic;color:#39bae6;">Send</span><span>&gt;(</span><span style="color:#f29718;">chan</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span>Channel&lt;T&gt;) </span><span style="color:#bfbab0cc;">-&gt;</span><span> T</span><span style="color:#bfbab0cc;">;
</span></code></pre>
<p>Каналы являются общими по типу передаваемых данных (часть API &lt;T: Send&gt;). Часть «Отправить» означает, что T следует считать безопасным для передачи между потоками; мы вернемся к этому позже в посте, но пока достаточно знать, что Vec<i32> - это Отправить.</p>
<p>Как всегда в Rust, передача T функции send означает передачу права собственности на нее. Этот факт имеет серьезные последствия: это означает, что код, подобный приведенному ниже, вызовет ошибку компилятора. </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5c6773;">// Suppose chan: Channel&lt;Vec&lt;i32&gt;&gt;
</span><span>
</span><span style="color:#ff7733;">let mut</span><span> vec </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">Vec</span><span style="color:#f29668;">::</span><span>new()</span><span style="color:#bfbab0cc;">;
</span><span style="font-style:italic;color:#5c6773;">// do some computation
</span><span style="color:#f07178;">send</span><span>(</span><span style="color:#f29668;">&amp;</span><span>chan</span><span style="color:#bfbab0cc;">,</span><span> vec)</span><span style="color:#bfbab0cc;">;
</span><span style="color:#f07178;">print_vec</span><span>(</span><span style="color:#f29668;">&amp;</span><span>vec)</span><span style="color:#bfbab0cc;">;
</span></code></pre>
<p>Здесь поток создает вектор, отправляет его другому потоку, а затем продолжает его использовать. Поток, получающий вектор, может изменить его по мере продолжения работы этого потока, поэтому вызов print_vec может привести к состоянию гонки или, если на то пошло, ошибке использования после освобождения.</p>
<p>Вместо этого компилятор Rust выдаст сообщение об ошибке при вызове print_vec: </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span>Error</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">use</span><span> of moved value `vec`
</span></code></pre>
<p>Катастрофа предотвращена.</p>
<h2 id="zamki">Замки</h2>
<p>Другой способ справиться с параллелизмом - связать потоки через пассивное разделяемое состояние.</p>
<p>У параллелизма с общим состоянием плохая репутация. Легко забыть установить блокировку или иным образом изменить неправильные данные в неподходящее время, что приведет к плачевным результатам - настолько легко, что многие вообще отказываются от этого стиля.</p>
<p>Вот что говорит Руст:</p>
<ol>
<li>
<p>Параллелизм с разделяемым состоянием, тем не менее, является фундаментальным стилем программирования, необходимым для системного кода, для максимальной производительности и для реализации других стилей параллелизма.</p>
</li>
<li>
<p>Проблема действительно в случайно разделенном состоянии.</p>
</li>
</ol>
<p>Rust стремится предоставить вам инструменты для непосредственного преодоления параллелизма с разделяемым состоянием, независимо от того, используете ли вы методы блокировки или без блокировки.</p>
<p>В Rust потоки автоматически «изолированы» друг от друга по причине владения. Запись может происходить только тогда, когда поток имеет изменяемый доступ, либо владея данными, либо имея их изменяемое заимствование. В любом случае, поток гарантированно будет единственным, имеющим доступ в данный момент. Чтобы увидеть, как это работает, давайте посмотрим на блокировки.</p>
<p>Помните, что изменяемые заимствования не могут происходить одновременно с другими заимствованиями. Блокировки обеспечивают такую же гарантию («взаимное исключение») посредством синхронизации во время выполнения. Это приводит к API-интерфейсу блокировки, который напрямую подключается к системе владения Rust.</p>
<p>Вот упрощенная версия (стандартная библиотека более эргономична): </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5c6773;">// create a new mutex
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">mutex</span><span>&lt;T</span><span style="color:#bfbab0cc;">: </span><span style="font-style:italic;color:#39bae6;">Send</span><span>&gt;(</span><span style="color:#f29718;">t</span><span style="color:#bfbab0cc;">:</span><span> T) </span><span style="color:#bfbab0cc;">-&gt; </span><span>Mutex&lt;T&gt;</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span style="font-style:italic;color:#5c6773;">// acquire the lock
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">lock</span><span>&lt;T</span><span style="color:#bfbab0cc;">: </span><span style="font-style:italic;color:#39bae6;">Send</span><span>&gt;(</span><span style="color:#f29718;">mutex</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span>Mutex&lt;T&gt;) </span><span style="color:#bfbab0cc;">-&gt; </span><span>MutexGuard&lt;T&gt;</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span style="font-style:italic;color:#5c6773;">// access the data protected by the lock
</span><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">access</span><span>&lt;T</span><span style="color:#bfbab0cc;">: </span><span style="font-style:italic;color:#39bae6;">Send</span><span>&gt;(</span><span style="color:#f29718;">guard</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut </span><span>MutexGuard&lt;T&gt;) </span><span style="color:#bfbab0cc;">-&gt; </span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> T</span><span style="color:#bfbab0cc;">;
</span></code></pre>
<p>Этот API блокировки необычен во многих отношениях.</p>
<p>Во-первых, тип Mutex является универсальным для типа T данных, защищенных блокировкой. Когда вы создаете мьютекс, вы передаете право собственности на эти данные в мьютекс, немедленно отказываясь от доступа к нему. (Замки разблокируются при первом создании.)</p>
<p>Позже вы можете заблокировать поток, чтобы заблокировать поток, пока блокировка не будет получена. Эта функция также необычна тем, что предоставляет возвращаемое значение MutexGuard<T>. MutexGuard автоматически снимает блокировку при ее разрушении; отдельной функции разблокировки нет.</p>
<p>Единственный способ получить доступ к блокировке - использовать функцию доступа, которая превращает изменяемое заимствование охранника в изменяемое заимствование данных (с более короткой арендой): </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">use_lock</span><span>(</span><span style="color:#f29718;">mutex</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span>Mutex&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="color:#ff7733;">i32</span><span>&gt;&gt;) {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// acquire the lock, taking ownership of a guard;
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// the lock is held for the rest of the scope
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> guard </span><span style="color:#f29668;">= </span><span style="color:#f07178;">lock</span><span>(mutex)</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// access the data by mutably borrowing the guard
</span><span>    </span><span style="color:#ff7733;">let</span><span> vec </span><span style="color:#f29668;">= </span><span style="color:#f07178;">access</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> guard)</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// vec has type `&amp;mut Vec&lt;i32&gt;`
</span><span>    vec</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(</span><span style="color:#f29718;">3</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// lock automatically released here, when `guard` is destroyed
</span><span>}
</span></code></pre>
<p>Здесь есть два ключевых ингредиента:</p>
<ul>
<li>
<p>Изменяемая ссылка, возвращаемая access, не может пережить MutexGuard, из которого она заимствована.</p>
</li>
<li>
<p>Блокировка снимается только после уничтожения MutexGuard.</p>
</li>
</ul>
<p>В результате Rust применяет дисциплину блокировки: он не позволит вам получить доступ к данным, защищенным блокировкой, кроме случаев, когда блокировка удерживается. Любая попытка сделать иначе приведет к ошибке компилятора. Например, рассмотрим следующий «рефакторинг» с ошибками: </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">use_lock</span><span>(</span><span style="color:#f29718;">mutex</span><span style="color:#bfbab0cc;">: </span><span style="color:#f29668;">&amp;</span><span>Mutex&lt;</span><span style="font-style:italic;color:#39bae6;">Vec</span><span>&lt;</span><span style="color:#ff7733;">i32</span><span>&gt;&gt;) {
</span><span>    </span><span style="color:#ff7733;">let</span><span> vec </span><span style="color:#f29668;">= </span><span>{
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// acquire the lock
</span><span>        </span><span style="color:#ff7733;">let mut</span><span> guard </span><span style="color:#f29668;">= </span><span style="color:#f07178;">lock</span><span>(mutex)</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// attempt to return a borrow of the data
</span><span>        </span><span style="color:#f07178;">access</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> guard)
</span><span>
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// guard is destroyed here, releasing the lock
</span><span>    }</span><span style="color:#bfbab0cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// attempt to access the data outside of the lock.
</span><span>    vec</span><span style="color:#f29668;">.</span><span style="color:#f07178;">push</span><span>(</span><span style="color:#f29718;">3</span><span>)</span><span style="color:#bfbab0cc;">;
</span><span>}
</span></code></pre>
<p>Rust сгенерирует ошибку, определяющую проблему: </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span>error</span><span style="color:#bfbab0cc;">:</span><span> `guard` does not live long enough
</span><span style="color:#f07178;">access</span><span>(</span><span style="color:#f29668;">&amp;</span><span style="color:#ff7733;">mut</span><span> guard)
</span><span>            </span><span style="color:#f29668;">^~~~~
</span></code></pre>
<p>Катастрофа предотвращена.</p>
<h2 id="bezopasnost-potokov-i-otpravit">Безопасность потоков и «Отправить»</h2>
<p>Типично различать одни типы данных как «потокобезопасные», а другие нет. Потокобезопасные структуры данных используют достаточно внутренней синхронизации для одновременного безопасного использования несколькими потоками.</p>
<p>Например, Rust поставляется с двумя видами «умных указателей» для подсчета ссылок:</p>
<ul>
<li>
<p>Rc<T> обеспечивает подсчет ссылок посредством обычных операций чтения / записи. Это не потокобезопасный.</p>
</li>
<li>
<p>Arc<T> обеспечивает подсчет ссылок с помощью атомарных операций. Это потокобезопасный.</p>
</li>
</ul>
<p>Аппаратные атомарные операции, используемые Arc, более дороги, чем обычные операции, используемые Rc, поэтому лучше использовать Rc, чем Arc. С другой стороны, очень важно, чтобы Rc<T> никогда не переходил из одного потока в другой, потому что это может привести к условиям гонки, которые повреждают счетчик.</p>
<p>Обычно единственным выходом является тщательная документация; в большинстве языков нет семантического различия между потокобезопасными и небезопасными типами.</p>
<p>В Rust мир разделен на два типа типов данных: те, которые являются типами данных Send, что означает, что их можно безопасно перемещать из одного потока в другой, и те, которые имеют! Send, что означает, что это может быть небезопасно. Если все компоненты типа являются Send, то же самое относится и к этому типу, который охватывает большинство типов. Однако некоторые базовые типы по своей сути не являются потокобезопасными, поэтому также можно явно пометить такой тип, как Arc, как Send, сказав компилятору: «Поверьте мне, здесь я проверил необходимую синхронизацию».</p>
<p>Естественно, Arc - это Send, а Rc - нет.</p>
<p>Мы уже видели, что API-интерфейсы Channel и Mutex работают только с данными отправки. Поскольку они являются точкой, в которой данные пересекают границы потока, они также являются точкой принудительного применения для отправки.</p>
<p>Собирая все это вместе, программисты Rust могут с уверенностью воспользоваться преимуществами Rc и других небезопасных для потоков типов, зная, что если они когда-нибудь случайно попытаются отправить один в другой поток, компилятор Rust скажет: </p>
<pre style="background-color:#0f1419;color:#bfbab0;"><code><span>`Rc&lt;Vec&lt;i32&gt;&gt;` cannot be sent between threads safely
</span></code></pre>
<p>Катастрофа предотвращена.</p>
<h2 id="sovmestnoe-ispol-zovanie-steka-scoped">Совместное использование стека: &quot;scoped&quot;</h2>
<p>Упомянутый здесь API - старый, который был перемещен из стандартной библиотеки. Вы можете найти эквивалентную функциональность в crossbeam (документация для scope()) и scoped_threadpool (документация для scoped())</p>
<p>До сих пор все шаблоны, которые мы видели, включают создание структур данных в куче, которые совместно используются потоками. Но что, если бы мы захотели запустить несколько потоков, использующих данные, находящиеся в нашем стековом фрейме? Это может быть опасно: </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">parent</span><span>() {
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> vec </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">Vec</span><span style="color:#f29668;">::</span><span>new()</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// fill the vector
</span><span>    thread</span><span style="color:#f29668;">::</span><span>spawn(|| {
</span><span>        </span><span style="color:#f07178;">print_vec</span><span>(</span><span style="color:#f29668;">&amp;</span><span>vec)
</span><span>    })
</span><span>}
</span></code></pre>
<p>Дочерний поток принимает ссылку на vec, которая, в свою очередь, находится в стековом кадре родительского потока. Когда родительский процесс завершается, кадр стека выталкивается, но дочерний поток не в этом разбирается. Ой!</p>
<p>Чтобы исключить такую небезопасность памяти, базовый API порождения потоков в Rust выглядит примерно так: </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">spawn</span><span>&lt;F&gt;(</span><span style="color:#f29718;">f</span><span style="color:#bfbab0cc;">:</span><span> F) </span><span style="color:#ff7733;">where</span><span> F</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">&#39;static</span><span>, ...
</span></code></pre>
<p>Статическое ограничение - это способ грубо сказать, что заимствованные данные не допускаются в закрытии. Это означает, что функция, подобная parent выше, вызовет ошибку: </p>
<pre style="background-color:#0f1419;color:#bfbab0;"><code><span>error: `vec` does not live long enough
</span></code></pre>
<p>по сути, улавливая возможность выскакивания кадра родительского стека. Катастрофа предотвращена.</p>
<p>Но есть еще один способ гарантировать безопасность: убедиться, что кадр родительского стека остается на месте до завершения дочернего потока. Это шаблон программирования с ответвлением-соединением, часто используемый для параллельных алгоритмов «разделяй и властвуй». Rust поддерживает это, предоставляя вариант создания потоков с ограниченным объемом: </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">scoped</span><span>&lt;</span><span style="color:#ff7733;">&#39;a</span><span>, F&gt;(</span><span style="color:#f29718;">f</span><span style="color:#bfbab0cc;">:</span><span> F) </span><span style="color:#bfbab0cc;">-&gt; </span><span>JoinGuard&lt;</span><span style="color:#ff7733;">&#39;a</span><span>&gt; </span><span style="color:#ff7733;">where</span><span> F</span><span style="color:#bfbab0cc;">: </span><span style="color:#ff7733;">&#39;a</span><span>, ...
</span></code></pre>
<p>Есть два ключевых отличия от API спауна, описанного выше:</p>
<ul>
<li>
<p>Используйте параметр a, а не static. Этот параметр представляет область, которая охватывает все заимствования в рамках замыкания f.</p>
</li>
<li>
<p>Возвращаемое значение - JoinGuard. Как следует из названия, JoinGuard гарантирует, что родительский поток присоединяется (ожидает) к своему дочернему, выполняя неявное соединение в своем деструкторе (если оно еще не произошло явно).</p>
</li>
</ul>
<p>Включение 'a в JoinGuard гарантирует, что JoinGuard не сможет выйти из области каких-либо данных, заимствованных при закрытии. Другими словами, Rust гарантирует, что родительский поток ожидает завершения дочернего процесса, прежде чем выталкивать любые кадры стека, к которым дочерний процесс может иметь доступ.</p>
<p>Таким образом, изменив наш предыдущий пример, мы можем исправить ошибку и удовлетворить компилятор: </p>
<pre data-lang="rust" style="background-color:#0f1419;color:#bfbab0;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ff7733;">fn </span><span style="color:#ffb454;">parent</span><span>() {
</span><span>    </span><span style="color:#ff7733;">let mut</span><span> vec </span><span style="color:#f29668;">= </span><span style="font-style:italic;color:#39bae6;">Vec</span><span style="color:#f29668;">::</span><span>new()</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// fill the vector
</span><span>    </span><span style="color:#ff7733;">let</span><span> guard </span><span style="color:#f29668;">= </span><span>thread</span><span style="color:#f29668;">::</span><span>scoped(|| {
</span><span>        </span><span style="color:#f07178;">print_vec</span><span>(</span><span style="color:#f29668;">&amp;</span><span>vec)
</span><span>    })</span><span style="color:#bfbab0cc;">;
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// guard destroyed here, implicitly joining
</span><span>}
</span></code></pre>
<p>Таким образом, в Rust вы можете свободно заимствовать данные стека в дочерние потоки, будучи уверенными, что компилятор проверит достаточную синхронизацию.</p>
<h2 id="gonki-za-dannye">Гонки за данные</h2>
<p>На данный момент мы увидели достаточно, чтобы решительно заявить о подходе Rust к параллелизму: компилятор предотвращает все гонки данных.</p>
<pre style="background-color:#0f1419;color:#bfbab0;"><code><span>Гонка за данными - это любой несинхронизированный одновременный доступ к данным, включающий запись.
</span></code></pre>
<p>Синхронизация здесь включает в себя такие низкоуровневые вещи, как атомарные инструкции. По сути, это способ сказать, что вы не можете случайно «разделить состояние» между потоками; весь (изменяющийся) доступ к состоянию должен быть обеспечен некоторой формой синхронизации.</p>
<p>Гонки данных - это всего лишь один (очень важный) вид состояния гонки, но, предотвращая их, Rust часто помогает предотвратить и другие, более тонкие гонки. Например, часто важно, чтобы обновления в разных местах происходили атомарно: другие потоки видят либо все обновления, либо ни одного из них. В Rust одновременный доступ &amp;mut к соответствующим местоположениям гарантирует атомарность их обновлений, поскольку ни один другой поток не может иметь одновременный доступ для чтения.</p>
<p>Стоит ненадолго остановиться и подумать об этой гарантии в более широком контексте языков. Многие языки обеспечивают безопасность памяти за счет сборки мусора. Но сборка мусора не помогает предотвратить скачки данных.</p>
<p>Вместо этого Rust использует владение и заимствование для обеспечения двух своих ключевых ценностных предложений:</p>
<ul>
<li>Безопасность памяти без сборки мусора.</li>
<li>Параллелизм без гонок данных.</li>
</ul>
<h2 id="budushchee">Будущее</h2>
<p>Когда Rust только начинался, он врезал каналы прямо в язык, занимая очень жесткую позицию в отношении параллелизма.</p>
<p>В сегодняшнем Rust параллелизм - это полностью библиотечное дело; все, что описано в этом посте, включая Send, определено в стандартной библиотеке и вместо этого может быть определено во внешней библиотеке.</p>
<p>И это очень интересно, потому что это означает, что история параллелизма в Rust может бесконечно развиваться, расширяться, охватывать новые парадигмы и выявлять новые классы ошибок. Такие библиотеки, как syncbox и simple_parallel, делают некоторые из первых шагов, и мы ожидаем, что в следующие несколько месяцев мы вложим значительные средства в это пространство. Быть в курсе! </p>










<script src="https://giscus.app/client.js"
    data-repo="dudochkin-victor&#x2F;dudochkin-victor.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkzNzgwNTYx"
    data-category="General"
    data-category-id="DIC_kwDOADmv0c4CAhvj"
    data-mapping="pathname"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async>
</script>



        </div>

        
        
    </main>

    
    <footer>
        <small class="subtext">
            <a href="https://angular-rust.github.io">Dudochkin Victor</a> © 2021
        </small>
    </footer>
    
</body>
<script>
    function highlightNav(heading) {
        let pathname = location.pathname;
        document.querySelectorAll(".toc a").forEach((item) => {
            item.classList.remove("active");
        });
        document.querySelector(".toc a[href$='" + pathname + "#" + heading + "']").classList.add("active");
    }

    let currentHeading = "";
    window.onscroll = function () {
        let h = document.querySelectorAll("h1,h2,h3,h4,h5,h6");
        let elementArr = [];

        h.forEach(item => {
            if (item.id !== "") {
                elementArr[item.id] = item.getBoundingClientRect().top;
            }
        });
        elementArr.sort();
        for (let key in elementArr) {
            if (!elementArr.hasOwnProperty(key)) {
                continue;
            }
            if (elementArr[key] > 0 && elementArr[key] < 300) {
                if (currentHeading !== key) {
                    highlightNav(key);
                    currentHeading = key;
                }
                break;
            }
        }
    }
</script>

</html>
