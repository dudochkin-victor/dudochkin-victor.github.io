+++
title = "–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏"
sort_by = "weight"
updated = 2022-10-02T15:00:00Z
+++

–í —ç—Ç–æ–π —á–∞—Å—Ç–∏ –º—ã –¥–æ–±–∞–≤–∏–º —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –≤ –Ω–∞—à –±—é–ª–ª–µ—Ç–µ–Ω—å, —á—Ç–æ–±—ã:

- –õ—é–¥–∏ –º–æ–≥—É—Ç –≥–æ–ª–æ—Å–æ–≤–∞—Ç—å –∑–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è
- –õ—é–¥–∏ –º–æ–≥—É—Ç –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞—Ç—å —Å–≤–æ–∏ –≥–æ–ª–æ—Å–∞
- –ü—Ä–µ–¥—Å–µ–¥–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç –Ω–∞–∑–Ω–∞—á–∞—Ç—å –ø—Ä–∞–≤–æ –≥–æ–ª–æ—Å–∞

### –ö–æ–Ω—Ç—Ä–∞–∫—Ç–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å <a id="contract-functionality"></a>

**–ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä:**

–î–∞–≤–∞–π—Ç–µ —Å–Ω–∞—á–∞–ª–∞ –æ–±–Ω–æ–≤–∏–º –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –Ω–∞—à–µ–≥–æ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞. –ö–∞–∫ –≤—ã –º–æ–∂–µ—Ç–µ –≤–∏–¥–µ—Ç—å –≤ –ø—Ä–∏–º–µ—Ä–µ –∫–æ–¥–∞ —Å–ø—Ä–∞–≤–∞, –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä —Ç–µ–ø–µ—Ä—å –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä `Option<Vector<String>>`. –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –æ–∂–∏–¥–∞–µ—Ç –Ω–∞ –≤—Ö–æ–¥–µ –≤–µ–∫—Ç–æ—Ä —Å—Ç—Ä–æ–∫. –ù–∞–º –Ω—É–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä, —á—Ç–æ–±—ã –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ –∏–º–µ–Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏—Å—å –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–æ–≤ ¬´–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ¬ª –∏ –¥–æ–±–∞–≤–ª—è–ª–∏—Å—å –≤ –Ω–∞—à–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è –±—é–ª–ª–µ—Ç–µ–Ω–µ–π. –ß—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω –ª–∏ –≤–µ–∫—Ç–æ—Ä, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π —Å—Ç—Ä–æ–∫–∏:

```rust
    if proposal_name.is_some() {
        names = proposal_name.unwrap()
        // do somethiing with names 

    }
```

**–ü—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å –ø—Ä–∞–≤–æ –≥–æ–ª–æ—Å–∞:**

–í –ø—Ä–µ–¥—ã–¥—É—â–µ–π —á–∞—Å—Ç–∏ –º—ã —Å–æ–∑–¥–∞–ª–∏ —Ñ—É–Ω–∫—Ü–∏—é, –ø–æ–∑–≤–æ–ª—è—é—â—É—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –¥–æ–±–∞–≤–ª—è—Ç—å —Å–µ–±—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∏–∑–±–∏—Ä–∞—Ç–µ–ª–µ–π. –ú—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–ª–∏ –∏—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∏–∑–±–∏—Ä–∞—Ç–µ–ª—è –∑–Ω–∞—á–µ–Ω–∏–µ–º `voter.weight=0`, –ø–æ—Å–∫–æ–ª—å–∫—É –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–∑–±–∏—Ä–∞—Ç–µ–ª—è –æ–Ω/–æ–Ω–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –Ω–µ –∏–º–µ–µ—Ç –ø—Ä–∞–≤–∞ –≥–æ–ª–æ—Å–∞. –ò—Ç–∞–∫, –¥–∞–≤–∞–π—Ç–µ —Å–æ–∑–¥–∞–¥–∏–º —Ñ—É–Ω–∫—Ü–∏—é `give_voting_right`, –∫–æ—Ç–æ—Ä–∞—è –ø–æ–∑–≤–æ–ª–∏—Ç —Ç–æ–ª—å–∫–æ –ø—Ä–µ–¥—Å–µ–¥–∞—Ç–µ–ª—é –æ–±–Ω–æ–≤–∏—Ç—å –≤–µ—Å –¥–æ 1 –¥–ª—è –ª—é–±–æ–≥–æ –¥–∞–Ω–Ω–æ–≥–æ –∏–∑–±–∏—Ä–∞—Ç–µ–ª—è. –§—É–Ω–∫—Ü–∏—è –±—É–¥–µ—Ç –≤—ã–≥–ª—è–¥–µ—Ç—å –ø—Ä–∏–º–µ—Ä–Ω–æ —Ç–∞–∫:

```rust
    // assuming that the caller is the chair person
    pub fn give_voting_right(&mut self, voter_id: AccountId) {
        let voter_opt = self.voters.get_mut(&voter_id);
        if voter_opt.is_some() {
            let voter = voter.unwrap()
            // assuming that the voter has not already voted
            voter.weight = 1
        }
    }
```

**–ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ:**

–¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ —Ä–µ–∞–ª–∏–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è –ø–æ–∑–≤–æ–ª–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –æ—Ç–¥–∞–≤–∞—Ç—å —Å–≤–æ–∏ –≥–æ–ª–æ—Å–∞. –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –±—É–¥–µ—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å –∏–Ω–¥–µ–∫—Å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö. –ï—Å–ª–∏ ¬´–≤—ã–∑—ã–≤–∞—é—â–∏–π¬ª —è–≤–ª—è–µ—Ç—Å—è –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º –∏–∑–±–∏—Ä–∞—Ç–µ–ª–µ–º –∏ –µ—â–µ –Ω–µ –æ—Ç–¥–∞–ª —Å–≤–æ–π –≥–æ–ª–æ—Å, –æ–±–Ω–æ–≤–∏—Ç–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –≤ –∏–Ω–¥–µ–∫—Å–µ ¬´i¬ª —Å –≤–µ—Å–æ–º –∏–∑–±–∏—Ä–∞—Ç–µ–ª—è, –æ–±–Ω–æ–≤–∏—Ç–µ ¬´voter.voted¬ª –¥–æ ¬´–∏—Å—Ç–∏–Ω–∞¬ª –∏ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ ¬´voter.vote¬ª –Ω–∞ –∏–Ω–¥–µ–∫—Å `–∏`.

**–ü–æ–ª—É—á–∏—Ç—å –≤—ã–∏–≥—Ä—ã—à–Ω–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ:**

–¢–µ–ø–µ—Ä—å, –∫–æ–≥–¥–∞ –≥–æ–ª–æ—Å–∞ –ø–æ–¥–∞–Ω—ã, –º—ã —Ä–µ–∞–ª–∏–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è –ø–æ–ª—É—á–∏—Ç –∏–º—è –≤—ã–∏–≥—Ä–∞–≤—à–µ–≥–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è. –ù–∞ –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –≤—ã–±–æ—Ä–∞—Ö –ø–æ–±–µ–¥–∏—Ç–µ–ª—å –æ–±—ä—è–≤–ª—è–µ—Ç—Å—è –ø–æ –∏—Å—Ç–µ—á–µ–Ω–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏—è. –ú—ã –æ—Å—Ç–∞–≤–∏–º –≤–∞–º —Ç–∞–∫—É—é —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é. –ù–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –º—ã –ø–æ–∑–≤–æ–ª–∏–º –ª—é–±–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –≤—ã–∑—ã–≤–∞—Ç—å —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –∏ –ø–æ–ª—É—á–∞—Ç—å –∏–º—è –≤—ã–∏–≥—Ä–∞–≤—à–µ–≥–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è. –î–∞–≤–∞–π—Ç–µ —Ä–µ–∞–ª–∏–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –∏–Ω–¥–µ–∫—Å–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –≥–æ–ª–æ—Å–æ–≤:

```rust
    fn winning_proposal(&self) -> Option<usize> {
        let mut winning_vote_vount:u32 = 0;
        let mut winning_index: Option<usize> = None;
        let mut index: usize = 0;

        for val in self.proposals.iter() {
            if val.vote_count > winning_vote_vount {
                winning_vote_vount = val.vote_count;
                winning_index = Some(index);
            }
            index += 1

        }
        return winning_index
    }
```

–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç `Option<usize>`, –∞ –Ω–µ `usize`, —Ç–∞–∫ –∫–∞–∫ –≤–æ–∑–º–æ–∂–Ω–æ, —á—Ç–æ –≤ –±—é–ª–ª–µ—Ç–µ–Ω–µ –Ω–µ—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π. –≠—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è –ø–æ–∏—Å–∫–∞ –Ω–∞–∑–≤–∞–Ω–∏—è –≤—ã–∏–≥—Ä–∞–≤—à–µ–≥–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è.

**–î–µ–ª–µ–≥–∞—Ü–∏—è:**

–í –Ω–∞—à–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –∏–∑–±–∏—Ä–∞—Ç–µ–ª—è –µ—Å—Ç—å –ø–æ–ª–µ `–¥–µ–ª–µ–≥–∞—Ç–∞`, –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –∫–∞–∫ `Option<AccountId>`, –ø–æ–∑–≤–æ–ª—è—é—â–µ–µ –∏–∑–±–∏—Ä–∞—Ç–µ–ª—è–º –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞—Ç—å —Å–≤–æ–π –≥–æ–ª–æ—Å –∫–æ–º—É-—Ç–æ –¥—Ä—É–≥–æ–º—É. –≠—Ç–æ–≥–æ –º–æ–∂–Ω–æ –¥–æ–±–∏—Ç—å—Å—è —Å –ø–æ–º–æ—â—å—é —Å–ª–µ–¥—É—é—â–µ–π —Ñ—É–Ω–∫—Ü–∏–∏:

```rust
    #[ink(message)]
    pub fn delegate(&mut self, to: AccountId)  {

        // account id of the person who invoked the function
        let sender_id = self.env().caller();
        let sender_weight;
        // self delegation is not allowd
        assert_ne!(to,sender_id, "Self-delegation is disallowed.");

        {
            let sender_opt =  self.voters.get_mut(&sender_id);
            // the voter invoking the function should exist in our ballot
            assert_eq!(sender_opt.is_some(),true, "Caller is not a valid voter");
            let sender = sender_opt.unwrap();

            // the voter must not have already casted their vote
            assert_eq!(sender.voted,false, "You have already voted");

            sender.voted = true;
            sender.delegate = Some(to);
            sender_weight = sender.weight;
        }

        {
            let delegate_opt = self.voters.get_mut(&to);
            // the person to whom the vote is being delegated must be a valid voter
            assert_eq!(delegate_opt.is_some(),true, "The delegated address is not valid");

            let delegate = delegate_opt.unwrap();

            // the voter should not have already voted
            if delegate.voted {
                // If the delegate already voted,
                // directly add to the number of votes
                let voted_to = delegate.vote.unwrap() as usize;
                self.proposals[voted_to].vote_count += sender_weight;
            } else {
                // If the delegate did not vote yet,
                // add to her weight.
                delegate.weight += sender_weight;
            }
        }
    }
```

–í—ã —É–≤–∏–¥–∏—Ç–µ, —á—Ç–æ –≤ –ø—Ä–∏–≤–µ–¥–µ–Ω–Ω–æ–π –≤—ã—à–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –º—ã –æ–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª—è `sender.voted` –∏ `sender.delegate` –ø–µ—Ä–µ–¥ –ø—Ä–æ–≤–µ—Ä–∫–æ–π, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –¥–µ–ª–µ–≥–∏—Ä—É–µ–º–æ–µ –ª–∏—Ü–æ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º –∏–∑–±–∏—Ä–∞—Ç–µ–ª–µ–º. –§—É–Ω–∫—Ü–∏—è –∑–∞–ø–∞–Ω–∏–∫—É–µ—Ç, –µ—Å–ª–∏ –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ª–∏—Ü–æ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º –∏–∑–±–∏—Ä–∞—Ç–µ–ª–µ–º, –∏ –æ—Ç–º–µ–Ω–∏—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è, –≤–Ω–µ—Å–µ–Ω–Ω—ã–µ –≤ –ø–æ–ª—è `sender.voted` –∏ `sender.delegate`.

## –¢–≤–æ—è –æ—á–µ—Ä–µ–¥—å! <a id="your-turn"></a>

–ù–∞ —ç—Ç–æ–º —É—Ä–æ–∫ –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è. –ü—Ä–∞–∫—Ç–∏–∫—É–π—Ç–µ –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –∑–Ω–∞–Ω–∏—è —Å –ø–æ–º–æ—â—å—é —Å–ª–µ–¥—É—é—â–∏—Ö —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π:

- –û–±–Ω–æ–≤–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é ¬´–∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä¬ª, —á—Ç–æ–±—ã –ø—Ä–∏ —É–∫–∞–∑–∞–Ω–∏–∏ –≤–µ–∫—Ç–æ—Ä–∞ –∏–º–µ–Ω –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π —Å–æ–∑–¥–∞–≤–∞–ª—Å—è –Ω–æ–≤—ã–π –æ–±—ä–µ–∫—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –∏ –¥–æ–±–∞–≤–ª—è–ª—Å—è –≤ ¬´ballot.proposal¬ª.
- –û–ø—Ä–µ–¥–µ–ª–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é `give_voting_right` –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º–∏.
- –î–æ–±–∞–≤—å—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é ¬´–≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏—è¬ª –∏ –æ–±–Ω–æ–≤–∏—Ç–µ –±—é–ª–ª–µ—Ç–µ–Ω—å –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º–∏ —à–∞–±–ª–æ–Ω–∞.
- –û–±–Ω–æ–≤–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å `get_winning_proposal_name`, —á—Ç–æ–±—ã –≤–µ—Ä–Ω—É—Ç—å –∏–º—è –≤—ã–∏–≥—Ä–∞–≤—à–µ–≥–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è.

{% tabs %}
{% tab title="üî®Starting Point" %}

```rust
#![cfg_attr(not(feature = "std"), no_std)]

use ink_lang as ink;

#[ink::contract]    
mod ballot {
    // use Hash
    use ink_storage::collections::HashMap;
    use ink_prelude::vec::Vec;
    use ink_storage::traits::{PackedLayout, SpreadLayout};

    // Structure to store Proposal information
    #[derive(Clone, Debug, scale::Encode, scale::Decode, SpreadLayout, PackedLayout,scale_info::TypeInfo)]
    struct Proposal {
        name: String,
        vote_count: u32, 
    }

    // Structure to store Proposal information
    #[derive(Clone, Debug, scale::Encode, scale::Decode, SpreadLayout, PackedLayout,scale_info::TypeInfo)]
    pub struct Voter {
        weight: u32,
        voted: bool,
        delegate: Option<AccountId>, 
        vote: Option<i32>, 
    }

    /// Defines the storage of your contract.
    /// Add new fields to the below struct in order
    /// to add new static storage fields to your contract.
    #[ink(storage)]
    pub struct Ballot {
        chair_person: AccountId,
        voters: HashMap<AccountId, Voter>,
        proposals: Vec<Proposal>    
    }

    impl Ballot {
        #[ink(constructor)]
        pub fn new(proposal_names: Option<Vec<String>> ) -> Self {

            // get chair person address
            let chair_person =  Self::env().caller();

            // create empty propsal and voters
            let mut proposals: Vec<Proposal> = Vec::new();
            let mut voters = HashMap::new();

            // initialize chair person's vote
            voters.insert(chair_person, Voter{
                weight:1,
                voted:false,
                delegate: None,
                vote: None,
            });

            // ACTION : Check if proposal names are provided.
            //        * If yes then create and push proposal objects to proposals vector

            Self {
                chair_person,
                voters,
                proposals,
            }
        }

        /// default constrcutor
        #[ink(constructor)]
        pub fn default() -> Self {
            Self::new(Default::default())
        }

        #[ink(message)]
        pub fn get_chairperson(&self) -> AccountId {
            self.chair_person
        }

        pub fn get_voter(&self, voter_id: AccountId) -> Option<&Voter>{
            self.voters.get(&voter_id)
        }

        pub fn get_voter_count(&self) -> usize{
            self.voters.len() as usize
        }

        /// the function adds the provided voter id into possible
        /// list of voters. By default the voter has no voting right,
        /// the contract owner must approve the voter before he can cast a vote
        #[ink(message)]
        pub fn add_voter(&mut self, voter_id: AccountId) -> bool{

            let voter_opt = self.voters.get(&voter_id);
            // the voter does not exists
            if voter_opt.is_some() {
                return false
            }

            self.voters.insert(voter_id, Voter{
                weight:0,
                voted:false,
                delegate: None,
                vote: None,
            });
            return true
        }

        /// given an index returns the name of the proposal at that index
        pub fn get_proposal_name_at_index(&self, index:usize) -> &String {
            let proposal = self.proposals.get(index).unwrap();
            return &proposal.name
        }

        /// returns the number of proposals in ballet
        pub fn get_proposal_count(&self) -> usize {
            return self.proposals.len()
        }

        /// adds the given proposal name in ballet
        /// to do: check unqiueness of proposal,
        pub fn add_proposal(&mut self, proposal_name: String){
            self.proposals.push(
                Proposal{
                    name:String::from(proposal_name),
                    vote_count: 0,
            });
        }

        #[ink(message)]
        pub fn give_voting_right(&mut self, voter_id: AccountId) {
            let caller = self.env().caller();
            let voter_opt = self.voters.get_mut(&voter_id);
        }
    }
}
```

{% endtab %}

{% tab title="‚úÖPotential Solution" %}

```rust
#![cfg_attr(not(feature = "std"), no_std)]

use ink_lang as ink;

#[ink::contract]    
mod ballot {
    // use Hash
    use ink_storage::collections::HashMap;
    use ink_prelude::vec::Vec;
    use ink_storage::traits::{PackedLayout, SpreadLayout};

    // Structure to store Proposal information
    #[derive(Clone, Debug, scale::Encode, scale::Decode, SpreadLayout, PackedLayout,scale_info::TypeInfo)]
    struct Proposal {
        name: String,
        vote_count: u32, 
    }

    // Structure to store Proposal information
    #[derive(Clone, Debug, scale::Encode, scale::Decode, SpreadLayout, PackedLayout,scale_info::TypeInfo)]
    pub struct Voter {
        weight: u32,
        voted: bool,
        delegate: Option<AccountId>, 
        vote: Option<i32>, 
    }

    /// Defines the storage of your contract.
    /// Add new fields to the below struct in order
    /// to add new static storage fields to your contract.
    #[ink(storage)]
    pub struct Ballot {
        chair_person: AccountId,
        voters: HashMap<AccountId, Voter>,
        proposals: Vec<Proposal>    
    }

    impl Ballot {
        #[ink(constructor)]
        pub fn new(proposal_names: Option<Vec<String>> ) -> Self {

            // get chair person address
            let chair_person =  Self::env().caller();

            // create empty propsal and voters
            let mut proposals: Vec<Proposal> = Vec::new();
            let mut voters = HashMap::new();

            // initialize chair person's vote
            voters.insert(chair_person, Voter{
                weight:1,
                voted:false,
                delegate: None,
                vote: None,
            });


            // ACTION : Check if proposal names are provided.
            //        * If yes then create and push proposal objects to proposals vector
            // if proposals are provided
            if proposal_names.is_some() {
                // store the provided propsal names
                let names = proposal_names.unwrap();
                for name in &names {
                    proposals.push(
                        Proposal{
                        name: String::from(name),
                        vote_count: 0,
                    });
                }
            }

            Self {
                chair_person,
                voters,
                proposals,
            }
        }

        /// default constrcutor
        #[ink(constructor)]
        pub fn default() -> Self {
            Self::new(Default::default())
        }

        #[ink(message)]
        pub fn get_chairperson(&self) -> AccountId {
            self.chair_person
        }

        pub fn get_voter(&self, voter_id: AccountId) -> Option<&Voter>{
            self.voters.get(&voter_id)
        }

        pub fn get_voter_count(&self) -> usize{
            self.voters.len() as usize
        }

        /// the function adds the provided voter id into possible
        /// list of voters. By default the voter has no voting right,
        /// the contract owner must approve the voter before he can cast a vote
        #[ink(message)]
        pub fn add_voter(&mut self, voter_id: AccountId) -> bool{

            let voter_opt = self.voters.get(&voter_id);
            // the voter does not exists
            if voter_opt.is_some() {
                return false
            }

            self.voters.insert(voter_id, Voter{
                weight:0,
                voted:false,
                delegate: None,
                vote: None,
            });
            return true
        }

        /// given an index returns the name of the proposal at that index
        pub fn get_proposal_name_at_index(&self, index:usize) -> &String {
            let proposal = self.proposals.get(index).unwrap();
            return &proposal.name
        }

        /// returns the number of proposals in ballet
        pub fn get_proposal_count(&self) -> usize {
            return self.proposals.len()
        }

        /// adds the given proposal name in ballet
        /// to do: check unqiueness of proposal,
        pub fn add_proposal(&mut self, proposal_name: String){
            self.proposals.push(
                Proposal{
                    name:String::from(proposal_name),
                    vote_count: 0,
            });
        }
        /// Give `voter` the right to vote on this ballot.
        /// Should only be called by `chairperson`.
        #[ink(message)]
        pub fn give_voting_right(&mut self, voter_id: AccountId) {
            let caller = self.env().caller();
            let voter_opt = self.voters.get_mut(&voter_id);
            // ACTION: check if the caller is the chair_person
            //         * check if the voter_id exists in ballot
            //         * check if voter has not already voted
            //         * if everything alright update voters weight to 1    // only chair person can give right to vote
            assert_eq!(caller,self.chair_person, "only chair person can give right to vote");    // the voter does not exists
            assert_eq!(voter_opt.is_some(),true, "provided voterId does not exist");    let voter = voter_opt.unwrap();    // the voter should not have already voted
            assert_eq!(voter.voted,false, "the voter has already voted");    voter.weight = 1;
        }
    }
}
```

{% endtab %}
{% endtabs %}
