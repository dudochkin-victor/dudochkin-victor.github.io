+++
title = "Взгляд разработчика JavaScript на Rust"
description = "Взгляд разработчика JavaScript на Rust"
weight = 1
hash = "5407a787"
+++

[Перевод](https://medium.com/swlh/a-javascript-developers-view-of-rust-e702c11262c6) | Автор оригинала: xxxx

Некоторое время назад я пытался найти что-нибудь интересное для чтения в Интернете, когда наткнулся на Rust. Rust - это…
  
> «Язык, позволяющий каждому создавать надежное и эффективное программное обеспечение».

Короче говоря, это язык системного программирования. Причем чертовски быстрый. Он даже превзошел C++ во многих тестах, проводимых The Computer Language Benchmarks Game (в основном связанных со сложными алгоритмическими задачами, такими как двоичные деревья и т.д.).

Однако, прежде чем я начал больше углубляться в сам язык, я попытался понять, что люди думают о нем. Rust был создан в 2011 году и поддерживается некоммерческой организацией Mozilla. За ним следует своего рода нишевая группа, состоящая в основном из предыдущих разработчиков C/C++, которые хотели отдохнуть от исключений с нулевым указателем, неопределенного поведения, сложности языка, сумасшедших макросов - я продолжу? Хотя Rust все еще находится на ранней стадии развития, у него есть веб-сайт, посвященный разработке игрового программирования, что довольно приятно. Есть даже игры, которые вызывают много шума и даже были помещены в App Store и Google Play Store, например, A Snake’s Tale. У Rust даже есть УДИВИТЕЛЬНЫЙ менеджер пакетов под названием Cargo, который сравним с npm и на сегодняшний день его скачали почти 1,5 миллиарда.

Увидев все это, я решил, что мне нужно удовлетворить свое любопытство и изучить синтаксис Rust. Я начал с чтения Книги - (в основном) полного пошагового руководства по синтаксису, идиомам и структуре программы Rust.

Поскольку я знаю много языков типа c, общая форма синтаксиса была простой и понятной. Если вы один из тех, кто по возможности использует const и будет наказывать тех, кто этого не делает, вам понравится Rust. Форма присвоения переменных по умолчанию делает их неизменяемыми. 

```rust
// Below is an immutable variable
let a = 5;
// Below is a mutable variable
let mut b = 5;
// General form for variables:
let var_name: type = value;
```

Типы данных в Rust просты. Целочисленные типы состоят из чисел без знака и со знаком от 8 до 128 битов.

![Целые числа](/imgs/posts/5407a787_01.png)

Существуют также неизменяемые типы массивов, символы, &str (ссылки на список символов в памяти), кортежи, перечисления, структуры, коллекции и т.д.

Функции объявляются с использованием ключевого слова fn следующим образом: 

```rust
fn main() {
  println!("Hello, world");
}
```

Вы можете указать возвращаемые значения с помощью символа ->, и если вы возвращаете значение в последней строке функции, нет необходимости включать ключевое слово return. 

```rust
// returns the 32-bit integer 5
fn my_function() -> u32 {
  5
}
```

Я медленно продвигался вперед, пока не натолкнулся на концепцию владения. Все программы должны управлять тем, как они используют память компьютера во время работы. Поскольку Rust не выполняет сборку мусора и программистам не нужно вручную выделять и освобождать память, памятью управляется через систему владения.

Вот правила владения в Rust (прямо из Книги):

- Каждое значение в Rust имеет переменную, которая называется его владельцем.
- Единовременно может быть только один владелец.
- Когда владелец выходит за рамки, значение будет сброшено.

Приведем пример: 

```rust
{                      // s is not valid here, it’s not yet declared
    let s = "hello";   // s is valid from this point forward

    // do stuff with s
}                      // this scope is now over, and s is no longer valid
```

Вот проблема, в которую я попал, когда впервые использовал Rust. 

```rust
let a = String::from("Hello, world!"); // a is the owner
let b = a; // ownership has changed to b. What is a?

println!("{}", a); // error[E0382]: borrow of moved value: `a`
```

Поскольку одновременно может быть только один владелец, я не могу попытаться присвоить значение переменной другой, используя имя первой переменной, если она была размещена в куче, как тип String в Rust. Теперь, если тип переменной является примитивным (int, double, bool и т.д.), Выполнение переназначения просто скопирует значение и НЕ изменит владельца.

При ссылке на переменную вы используете символ &, как в C/C++. Ссылки позволяют программисту принять значение, не принимая на себя ответственность. Одновременно может быть столько неизменяемых ссылок на переменную, сколько нужно, но только ОДНА изменяемая ссылка. 

```rust
let a = String::from("Dude, Rust is sick.");
{
  let b = &a; // ok
  let c = &a; // ok
}

{
  let b = &mut a; // mutable reference. ok.
  *b = String::from("Different!"); // change value. ok
}

{
  let b = &mut a; // ok
  let c = &mut a; // ERROR. Only one mut reference at a time!
}
```

Еще более сложным для меня было время жизни Rust, которое позволяет Rust обойтись с помощью сборки мусора. Это также их решение хорошо известной проблемы C++, связанной с висячими указателями, когда переменная «используется после освобождения». Я даже не буду пытаться здесь объяснять эту концепцию. Вы должны прочитать эту статью, чтобы узнать больше.

В целом, я бы сказал, что мой опыт работы с Rust был полезным. Мне было легко понять его синтаксис и руководство по стилю, хотя некоторые концепции поначалу было трудно понять. Не знаю, только ли это я, но даже то, как язык выглядит при вводе, элегантно. Он использует методы функционального программирования, обычно используемые в JavaScript (фильтрация, сопоставление и т.д.), А его ключевые слова синтаксиса короткие и слишком точные (fn, enum, let, mut, i32, &str)
Некоторые системные разработчики активно лоббируют, чтобы Rust стал следующим C/C++. Не знаю, случится ли это в ближайшее время, но одно можно сказать наверняка: он будет продолжать расти и развиваться. Он поддерживается Mozilla и имеет «культ» последователей, которые хотят убить C++.

Так что.

Взгляните на Rust. 