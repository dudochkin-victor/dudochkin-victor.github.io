+++
title = "Выбор Swift против Rust"
description = "Выбор Swift против Rust"
weight = 1
+++

[Перевод](https://medium.com/@eonil/choosing-swift-vs-rust-237bcb45d97b)

И Swift, и Rust - хорошие инструменты, у них есть свои плюсы и минусы. Проблема в том, что мне нужно сосредоточиться на одном деле, потому что у меня нет бесконечных ресурсов. Поэтому мне нужно строить предположения о будущем.

## Конвергентная эволюция

Язык развивается. В долгосрочном будущем Swift получит уникальное владение, семантику перемещения и поддержку макета памяти. В Rust будет больше удобства и поддержки инструментов. В конце концов, они оба будут эволюционировать одновременно. Но путь туда будет совсем другим.

## Сфокусированная эволюция
Разница в отрывках. Ресурсы ограничены. Разработчики должны установить приоритет и сосредоточиться на небольшом количестве целей. Обычно эти цели устанавливаются с учетом непосредственных потребностей поставщиков ресурсов, поэтому направление развития определяется тем, кто поддерживает ресурсы.

- Swift в основном поддерживается Apple. Поддержка сообщества очень слабая.
- Rust в основном поддерживается Mozilla. Поддержка сообщества очень сильна.

Основным сторонником Swift является Apple. Ближайшая проблема Apple - обеспечить лучшую среду разработки для своих платформ. Swift также обещает лучшую поддержку платформ сторонних производителей, но с гораздо меньшим приоритетом. Apple хотела улучшить Objective-C и не заменять свой код C ++ на более низкий уровень сейчас. Это делает главным приоритетом Swift лучшую поддержку разработки приложений пользовательского интерфейса Apple. Для них важнее совместимость с Objective-C, улучшенный синтаксис, поддержка IDE, поддержка DSL. Макет памяти на самом деле не имеет большого значения для разработки приложений пользовательского интерфейса. Команда Apple Swift потратит гораздо больше времени на реализацию более гладкой межоперационной поддержки Objective-C или существующей платформы Apple, а не на проверку заимствований.

Основным сторонником Rust является Mozilla. Ближайшая проблема Mozilla - продуктивность. Они устали от крайне низкой производительности C ++ и хотят немедленно заменить C ++. В наши дни веб-браузеры похожи на ОС. Разработка веб-браузера требует поддержки функций уровня разработки ОС. Им прямо сейчас нужны контроль компоновки памяти, сериализация, поддержка в реальном времени, нулевая абстракция, семантика перемещения, статическая межпоточная безопасность. Вот почему Rust предоставляет такие возможности сейчас, а не позже.

### Один пример: сериализация

Одним из примеров является поддержка сериализации. Rust несколько раз пытался обеспечить сериализацию, и в конце концов они получили serde. serde основан на генерации статического кода и может кодировать каждое дерево значений в Rust, включая типы сумм (перечисления с параметрическими значениями), с помощью нескольких строк кода. Более того, serde - это не волшебство компилятора. Это простой макрос, как и любой другой написанный вами код. Если вас не устраивает serde, вы можете реализовать свою собственную.

Соответствующее положение Swift - Codable. Удивительно, но он не может кодировать / декодировать типы сумм с первого раза. Может быть, в конечном итоге это произойдет, но никто не знает, когда, потому что его приоритет сильно отстает от других вещей, таких как привязка данных или поддержка ключевых путей. Хуже того, Codable по-прежнему нужен гораздо более сложный код, такой как дерьмо CodingKey, для правильного управления сериализацией. Кроме того, Codable - это полное волшебство компилятора, и нет никакого способа улучшить его, если вы не создадите свой собственный компилятор. А для участия в разработке компилятора Swift вы должны быть опытным программистом на C ++. Если вы хотите улучшить Swift, вам нужно писать код на C ++. Это ужасно, но на самом деле не проблема для Apple, поскольку у них есть почти бесконечное количество денег, чтобы нанять людей, которые разберутся с любым дерьмом. Но я не Apple. Все, что у меня есть, - это только мое личное время, и я не хочу тратить свою жизнь на то, чтобы написать повторяющееся декодирование типа суммы или загадочные ошибки C ++. 

### Другой пример: поддержка приложения в веб-браузере

Другой пример - поддержка приложений в веб-браузере. И Swift, и Rust относятся к семейству LLVM и могут быть скомпилированы в WASM. Здесь Rust уже имеет определенный уровень поддержки целевого веб-браузера, а Swift - нет.

Я не утверждаю, что Apple ненавидит Swift в веб-браузерах. Swift в веб-браузерах на самом деле добавляет больше достоинств языку Swift и может быть полезен для Apple. Но у Apple нет причин уделять этому приоритетное внимание. Apple сначала нужно поддержать свою платформу. А браузеры… ну, может, позже.

## Сценарии против оптимизации

До сих пор я заметил, что Swift разработан и разрабатывается как язык сценариев приложений. В отличие от других языков сценариев, Swift потенциально может поддерживать более низкоуровневые операции, но я думаю, что будет болезненно использовать такие низкоуровневые функции, даже если они реализуют это, потому что Swift ориентирован на приложения более высокого уровня. Я думаю, что Swift нацелен на Python, и было бы здорово, если бы я смог заменить Python скриптом Swift.
Rust стремится заменить C ++. Rust жертвует удобством ради производительности и предсказуемости.

## Взаимодействие

Идеальная ситуация - высокий уровень взаимодействия. Напишите код Rust для моделирования обработки чисел и напишите код Swift для управления ими. Если Swift добавит уникальную семантику владения и перемещения, это будет более осуществимо.

Для меня идеальной стратегией было бы сначала сосредоточиться на Rust. И подождите, пока Swift реализует семантику перемещения и уникальное владение. После этого сделать так, чтобы они играли хорошо, было бы намного проще, и, возможно, мы сможем смешать их изначально.

Я надеюсь, что когда-нибудь смогу это сделать. 